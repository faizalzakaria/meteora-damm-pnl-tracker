var __pow = Math.pow;
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/CpAmm.ts
import { Program, BN as BN10 } from "@coral-xyz/anchor";
import { NATIVE_MINT as NATIVE_MINT2, TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID2 } from "@solana/spl-token";
import invariant from "invariant";

// src/idl/cp_amm.json
var cp_amm_default = {
  address: "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG",
  metadata: {
    name: "cp_amm",
    version: "0.1.3",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "add_liquidity",
      discriminator: [
        181,
        157,
        89,
        67,
        143,
        182,
        52,
        72
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "AddLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "claim_partner_fee",
      discriminator: [
        97,
        206,
        39,
        105,
        94,
        94,
        126,
        148
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "partner",
          signer: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_position_fee",
      discriminator: [
        180,
        38,
        154,
        17,
        133,
        33,
        162,
        211
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_protocol_fee",
      discriminator: [
        165,
        228,
        133,
        48,
        99,
        249,
        255,
        33
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  48,
                  9,
                  89,
                  123,
                  106,
                  114,
                  131,
                  251,
                  50,
                  173,
                  254,
                  250,
                  10,
                  80,
                  160,
                  84,
                  143,
                  100,
                  81,
                  249,
                  134,
                  112,
                  30,
                  213,
                  50,
                  166,
                  239,
                  78,
                  53,
                  175,
                  188,
                  85
                ]
              },
              {
                kind: "account",
                path: "token_a_program"
              },
              {
                kind: "account",
                path: "token_a_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  48,
                  9,
                  89,
                  123,
                  106,
                  114,
                  131,
                  251,
                  50,
                  173,
                  254,
                  250,
                  10,
                  80,
                  160,
                  84,
                  143,
                  100,
                  81,
                  249,
                  134,
                  112,
                  30,
                  213,
                  50,
                  166,
                  239,
                  78,
                  53,
                  175,
                  188,
                  85
                ]
              },
              {
                kind: "account",
                path: "token_b_program"
              },
              {
                kind: "account",
                path: "token_b_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "claim_fee_operator",
          docs: [
            "Claim fee operator"
          ]
        },
        {
          name: "operator",
          docs: [
            "Operator"
          ],
          signer: true,
          relations: [
            "claim_fee_operator"
          ]
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_reward",
      discriminator: [
        149,
        95,
        181,
        242,
        94,
        90,
        158,
        162
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "reward_vault",
          docs: [
            "The vault token account for reward token"
          ],
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "user_token_account",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "skip_reward",
          type: "u8"
        }
      ]
    },
    {
      name: "close_claim_fee_operator",
      discriminator: [
        38,
        134,
        82,
        216,
        95,
        124,
        17,
        99
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_config",
      discriminator: [
        145,
        9,
        72,
        157,
        95,
        125,
        61,
        85
      ],
      accounts: [
        {
          name: "config",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_position",
      discriminator: [
        123,
        134,
        81,
        0,
        49,
        68,
        98,
        98
      ],
      accounts: [
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ],
          writable: true
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "owner",
          docs: [
            "Owner of position"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_token_badge",
      discriminator: [
        108,
        146,
        86,
        110,
        179,
        254,
        10,
        104
      ],
      accounts: [
        {
          name: "token_badge",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_claim_fee_operator",
      discriminator: [
        169,
        62,
        207,
        107,
        58,
        187,
        162,
        109
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  102,
                  95,
                  111,
                  112,
                  101,
                  114,
                  97,
                  116,
                  111,
                  114
                ]
              },
              {
                kind: "account",
                path: "operator"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_config",
      docs: [
        "ADMIN FUNCTIONS /////"
      ],
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "index",
          type: "u64"
        },
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "StaticConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_dynamic_config",
      discriminator: [
        81,
        251,
        122,
        78,
        66,
        57,
        208,
        82
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "arg",
                path: "index"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "index",
          type: "u64"
        },
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "DynamicConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_position",
      discriminator: [
        48,
        215,
        197,
        153,
        96,
        203,
        180,
        133
      ],
      accounts: [
        {
          name: "owner"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the position. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_token_badge",
      discriminator: [
        88,
        206,
        0,
        91,
        60,
        175,
        151,
        118
      ],
      accounts: [
        {
          name: "token_badge",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  98,
                  97,
                  100,
                  103,
                  101
                ]
              },
              {
                kind: "account",
                path: "token_mint"
              }
            ]
          }
        },
        {
          name: "token_mint"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "fund_reward",
      discriminator: [
        188,
        50,
        249,
        165,
        93,
        151,
        38,
        63
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "carry_forward",
          type: "bool"
        }
      ]
    },
    {
      name: "initialize_customizable_pool",
      discriminator: [
        20,
        161,
        241,
        24,
        189,
        221,
        180,
        2
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeCustomizablePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_pool",
      docs: [
        "USER FUNCTIONS ////"
      ],
      discriminator: [
        95,
        180,
        10,
        172,
        84,
        174,
        232,
        40
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_pool_with_dynamic_config",
      discriminator: [
        149,
        82,
        72,
        197,
        253,
        252,
        68,
        15
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "pool_creator_authority",
          signer: true,
          relations: [
            "config"
          ]
        },
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeCustomizablePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_reward",
      discriminator: [
        95,
        135,
        192,
        196,
        242,
        129,
        230,
        68
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  119,
                  97,
                  114,
                  100,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "pool"
              },
              {
                kind: "arg",
                path: "reward_index"
              }
            ]
          }
        },
        {
          name: "reward_mint"
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "reward_duration",
          type: "u64"
        },
        {
          name: "funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "lock_position",
      discriminator: [
        227,
        62,
        2,
        252,
        247,
        10,
        171,
        185
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "vesting",
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "VestingParameters"
            }
          }
        }
      ]
    },
    {
      name: "permanent_lock_position",
      discriminator: [
        165,
        176,
        125,
        6,
        231,
        171,
        186,
        213
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "permanent_lock_liquidity",
          type: "u128"
        }
      ]
    },
    {
      name: "refresh_vesting",
      discriminator: [
        9,
        94,
        216,
        14,
        116,
        204,
        247,
        0
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner"
        }
      ],
      args: []
    },
    {
      name: "remove_all_liquidity",
      discriminator: [
        10,
        51,
        61,
        35,
        112,
        105,
        24,
        85
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "token_a_amount_threshold",
          type: "u64"
        },
        {
          name: "token_b_amount_threshold",
          type: "u64"
        }
      ]
    },
    {
      name: "remove_liquidity",
      discriminator: [
        80,
        85,
        209,
        72,
        24,
        206,
        177,
        108
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "RemoveLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "set_pool_status",
      discriminator: [
        112,
        87,
        135,
        223,
        83,
        204,
        132,
        53
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "status",
          type: "u8"
        }
      ]
    },
    {
      name: "split_position",
      discriminator: [
        172,
        241,
        221,
        138,
        161,
        29,
        253,
        42
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "first_position",
            "second_position"
          ]
        },
        {
          name: "first_position",
          docs: [
            "The first position"
          ],
          writable: true
        },
        {
          name: "first_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "second_position",
          docs: [
            "The second position"
          ],
          writable: true
        },
        {
          name: "second_position_nft_account",
          docs: [
            "The token account for position nft"
          ]
        },
        {
          name: "first_owner",
          docs: [
            "Owner of first position"
          ],
          signer: true
        },
        {
          name: "second_owner",
          docs: [
            "Owner of second position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "SplitPositionParameters"
            }
          }
        }
      ]
    },
    {
      name: "swap",
      discriminator: [
        248,
        198,
        158,
        145,
        225,
        117,
        135,
        200
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "input_token_account",
          docs: [
            "The user token account for input token"
          ],
          writable: true
        },
        {
          name: "output_token_account",
          docs: [
            "The user token account for output token"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ]
        },
        {
          name: "payer",
          docs: [
            "The user performing the swap"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "referral_token_account",
          docs: [
            "referral token account"
          ],
          writable: true,
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "SwapParameters"
            }
          }
        }
      ]
    },
    {
      name: "update_reward_duration",
      discriminator: [
        138,
        174,
        196,
        169,
        213,
        235,
        254,
        107
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_duration",
          type: "u64"
        }
      ]
    },
    {
      name: "update_reward_funder",
      discriminator: [
        211,
        28,
        48,
        32,
        215,
        160,
        35,
        23
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "signer",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "withdraw_ineligible_reward",
      discriminator: [
        148,
        206,
        42,
        195,
        247,
        49,
        103,
        8
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "HLnpSz9h2S4hiLQ43rnSD9XkcUThA7B8hQMKmDaiTLcC"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "ClaimFeeOperator",
      discriminator: [
        166,
        48,
        134,
        86,
        34,
        200,
        188,
        150
      ]
    },
    {
      name: "Config",
      discriminator: [
        155,
        12,
        170,
        224,
        30,
        250,
        204,
        130
      ]
    },
    {
      name: "Pool",
      discriminator: [
        241,
        154,
        109,
        4,
        17,
        177,
        109,
        188
      ]
    },
    {
      name: "Position",
      discriminator: [
        170,
        188,
        143,
        228,
        122,
        64,
        247,
        208
      ]
    },
    {
      name: "TokenBadge",
      discriminator: [
        116,
        219,
        204,
        229,
        249,
        116,
        255,
        150
      ]
    },
    {
      name: "Vesting",
      discriminator: [
        100,
        149,
        66,
        138,
        95,
        200,
        128,
        241
      ]
    }
  ],
  events: [
    {
      name: "EvtAddLiquidity",
      discriminator: [
        175,
        242,
        8,
        157,
        30,
        247,
        185,
        169
      ]
    },
    {
      name: "EvtClaimPartnerFee",
      discriminator: [
        118,
        99,
        77,
        10,
        226,
        1,
        1,
        87
      ]
    },
    {
      name: "EvtClaimPositionFee",
      discriminator: [
        198,
        182,
        183,
        52,
        97,
        12,
        49,
        56
      ]
    },
    {
      name: "EvtClaimProtocolFee",
      discriminator: [
        186,
        244,
        75,
        251,
        188,
        13,
        25,
        33
      ]
    },
    {
      name: "EvtClaimReward",
      discriminator: [
        218,
        86,
        147,
        200,
        235,
        188,
        215,
        231
      ]
    },
    {
      name: "EvtCloseClaimFeeOperator",
      discriminator: [
        111,
        39,
        37,
        55,
        110,
        216,
        194,
        23
      ]
    },
    {
      name: "EvtCloseConfig",
      discriminator: [
        36,
        30,
        239,
        45,
        58,
        132,
        14,
        5
      ]
    },
    {
      name: "EvtClosePosition",
      discriminator: [
        20,
        145,
        144,
        68,
        143,
        142,
        214,
        178
      ]
    },
    {
      name: "EvtCreateClaimFeeOperator",
      discriminator: [
        21,
        6,
        153,
        120,
        68,
        116,
        28,
        177
      ]
    },
    {
      name: "EvtCreateConfig",
      discriminator: [
        131,
        207,
        180,
        174,
        180,
        73,
        165,
        54
      ]
    },
    {
      name: "EvtCreateDynamicConfig",
      discriminator: [
        231,
        197,
        13,
        164,
        248,
        213,
        133,
        152
      ]
    },
    {
      name: "EvtCreatePosition",
      discriminator: [
        156,
        15,
        119,
        198,
        29,
        181,
        221,
        55
      ]
    },
    {
      name: "EvtCreateTokenBadge",
      discriminator: [
        141,
        120,
        134,
        116,
        34,
        28,
        114,
        160
      ]
    },
    {
      name: "EvtFundReward",
      discriminator: [
        104,
        233,
        237,
        122,
        199,
        191,
        121,
        85
      ]
    },
    {
      name: "EvtInitializePool",
      discriminator: [
        228,
        50,
        246,
        85,
        203,
        66,
        134,
        37
      ]
    },
    {
      name: "EvtInitializeReward",
      discriminator: [
        129,
        91,
        188,
        3,
        246,
        52,
        185,
        249
      ]
    },
    {
      name: "EvtLockPosition",
      discriminator: [
        168,
        63,
        108,
        83,
        219,
        82,
        2,
        200
      ]
    },
    {
      name: "EvtPermanentLockPosition",
      discriminator: [
        145,
        143,
        162,
        218,
        218,
        80,
        67,
        11
      ]
    },
    {
      name: "EvtRemoveLiquidity",
      discriminator: [
        87,
        46,
        88,
        98,
        175,
        96,
        34,
        91
      ]
    },
    {
      name: "EvtSetPoolStatus",
      discriminator: [
        100,
        213,
        74,
        3,
        95,
        91,
        228,
        146
      ]
    },
    {
      name: "EvtSplitPosition",
      discriminator: [
        182,
        138,
        42,
        254,
        27,
        94,
        82,
        221
      ]
    },
    {
      name: "EvtSwap",
      discriminator: [
        27,
        60,
        21,
        213,
        138,
        170,
        187,
        147
      ]
    },
    {
      name: "EvtUpdateRewardDuration",
      discriminator: [
        149,
        135,
        65,
        231,
        129,
        153,
        65,
        57
      ]
    },
    {
      name: "EvtUpdateRewardFunder",
      discriminator: [
        76,
        154,
        208,
        13,
        40,
        115,
        246,
        146
      ]
    },
    {
      name: "EvtWithdrawIneligibleReward",
      discriminator: [
        248,
        215,
        184,
        78,
        31,
        180,
        179,
        168
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6003,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6004,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6005,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6006,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6007,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6008,
      name: "UnableToModifyActivationPoint",
      msg: "Unable to modify activation point"
    },
    {
      code: 6009,
      name: "InvalidAuthorityToCreateThePool",
      msg: "Invalid authority to create the pool"
    },
    {
      code: 6010,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6011,
      name: "InvalidActivationPoint",
      msg: "Invalid activation point"
    },
    {
      code: 6012,
      name: "InvalidQuoteMint",
      msg: "Quote token must be SOL,USDC"
    },
    {
      code: 6013,
      name: "InvalidFeeCurve",
      msg: "Invalid fee curve"
    },
    {
      code: 6014,
      name: "InvalidPriceRange",
      msg: "Invalid Price Range"
    },
    {
      code: 6015,
      name: "PriceRangeViolation",
      msg: "Trade is over price range"
    },
    {
      code: 6016,
      name: "InvalidParameters",
      msg: "Invalid parameters"
    },
    {
      code: 6017,
      name: "InvalidCollectFeeMode",
      msg: "Invalid collect fee mode"
    },
    {
      code: 6018,
      name: "InvalidInput",
      msg: "Invalid input"
    },
    {
      code: 6019,
      name: "CannotCreateTokenBadgeOnSupportedMint",
      msg: "Cannot create token badge on supported mint"
    },
    {
      code: 6020,
      name: "InvalidTokenBadge",
      msg: "Invalid token badge"
    },
    {
      code: 6021,
      name: "InvalidMinimumLiquidity",
      msg: "Invalid minimum liquidity"
    },
    {
      code: 6022,
      name: "InvalidVestingInfo",
      msg: "Invalid vesting information"
    },
    {
      code: 6023,
      name: "InsufficientLiquidity",
      msg: "Insufficient liquidity"
    },
    {
      code: 6024,
      name: "InvalidVestingAccount",
      msg: "Invalid vesting account"
    },
    {
      code: 6025,
      name: "InvalidPoolStatus",
      msg: "Invalid pool status"
    },
    {
      code: 6026,
      name: "UnsupportNativeMintToken2022",
      msg: "Unsupported native mint token2022"
    },
    {
      code: 6027,
      name: "InvalidRewardIndex",
      msg: "Invalid reward index"
    },
    {
      code: 6028,
      name: "InvalidRewardDuration",
      msg: "Invalid reward duration"
    },
    {
      code: 6029,
      name: "RewardInitialized",
      msg: "Reward already initialized"
    },
    {
      code: 6030,
      name: "RewardUninitialized",
      msg: "Reward not initialized"
    },
    {
      code: 6031,
      name: "InvalidRewardVault",
      msg: "Invalid reward vault"
    },
    {
      code: 6032,
      name: "MustWithdrawnIneligibleReward",
      msg: "Must withdraw ineligible reward"
    },
    {
      code: 6033,
      name: "IdenticalRewardDuration",
      msg: "Reward duration is the same"
    },
    {
      code: 6034,
      name: "RewardCampaignInProgress",
      msg: "Reward campaign in progress"
    },
    {
      code: 6035,
      name: "IdenticalFunder",
      msg: "Identical funder"
    },
    {
      code: 6036,
      name: "InvalidFunder",
      msg: "Invalid funder"
    },
    {
      code: 6037,
      name: "RewardNotEnded",
      msg: "Reward not ended"
    },
    {
      code: 6038,
      name: "FeeInverseIsIncorrect",
      msg: "Fee inverse is incorrect"
    },
    {
      code: 6039,
      name: "PositionIsNotEmpty",
      msg: "Position is not empty"
    },
    {
      code: 6040,
      name: "InvalidPoolCreatorAuthority",
      msg: "Invalid pool creator authority"
    },
    {
      code: 6041,
      name: "InvalidConfigType",
      msg: "Invalid config type"
    },
    {
      code: 6042,
      name: "InvalidPoolCreator",
      msg: "Invalid pool creator"
    },
    {
      code: 6043,
      name: "RewardVaultFrozenSkipRequired",
      msg: "Reward vault is frozen, must skip reward to proceed"
    },
    {
      code: 6044,
      name: "InvalidSplitPositionParameters",
      msg: "Invalid parameters for split position"
    },
    {
      code: 6045,
      name: "UnsupportPositionHasVestingLock",
      msg: "Unsupported split position has vesting lock"
    },
    {
      code: 6046,
      name: "SamePosition",
      msg: "Same position"
    }
  ],
  types: [
    {
      name: "AddLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "maximum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "maximum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "BaseFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "padding_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimFeeOperator",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            docs: [
              "operator"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "Config",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "vault_config_key",
            docs: [
              "Vault config key"
            ],
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            docs: [
              "Only pool_creator_authority can use the current config to initialize new pool. When it's Pubkey::default, it's a public config."
            ],
            type: "pubkey"
          },
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesConfig"
              }
            }
          },
          {
            name: "activation_type",
            docs: [
              "Activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "Collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "config_type",
            docs: [
              "Config type mode, 0 for static, 1 for dynamic"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding 0"
            ],
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "index",
            docs: [
              "config index"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "_padding_1",
            docs: [
              "Fee curve point",
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                10
              ]
            }
          }
        ]
      }
    },
    {
      name: "DynamicConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_creator_authority",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "DynamicFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "bin_step_u128",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "DynamicFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "last_update_timestamp",
            type: "u64"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "sqrt_price_reference",
            type: "u128"
          },
          {
            name: "volatility_accumulator",
            type: "u128"
          },
          {
            name: "volatility_reference",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtAddLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "AddLiquidityParameters"
              }
            }
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "total_amount_a",
            type: "u64"
          },
          {
            name: "total_amount_b",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimPartnerFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimPositionFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "fee_a_claimed",
            type: "u64"
          },
          {
            name: "fee_b_claimed",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimProtocolFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "total_reward",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCloseClaimFeeOperator",
      docs: [
        "Close claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "claim_fee_operator",
            type: "pubkey"
          },
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCloseConfig",
      docs: [
        "Close config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            docs: [
              "Config pubkey"
            ],
            type: "pubkey"
          },
          {
            name: "admin",
            docs: [
              "admin pk"
            ],
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtClosePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateClaimFeeOperator",
      docs: [
        "Create claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateConfig",
      docs: [
        "Create static config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          },
          {
            name: "config",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateDynamicConfig",
      docs: [
        "Create dynamic config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "index",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCreatePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateTokenBadge",
      docs: [
        "Create token badge"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtFundReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "amount",
            type: "u64"
          },
          {
            name: "transfer_fee_excluded_amount_in",
            type: "u64"
          },
          {
            name: "reward_duration_end",
            type: "u64"
          },
          {
            name: "pre_reward_rate",
            type: "u128"
          },
          {
            name: "post_reward_rate",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtInitializePool",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_mint",
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "payer",
            type: "pubkey"
          },
          {
            name: "alpha_vault",
            type: "pubkey"
          },
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "liquidity",
            type: "u128"
          },
          {
            name: "sqrt_price",
            type: "u128"
          },
          {
            name: "activation_point",
            type: "u64"
          },
          {
            name: "token_a_flag",
            type: "u8"
          },
          {
            name: "token_b_flag",
            type: "u8"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "total_amount_a",
            type: "u64"
          },
          {
            name: "total_amount_b",
            type: "u64"
          },
          {
            name: "pool_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtInitializeReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "vesting",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "EvtPermanentLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "lock_liquidity_amount",
            type: "u128"
          },
          {
            name: "total_permanent_locked_liquidity",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtRemoveLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "RemoveLiquidityParameters"
              }
            }
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtSetPoolStatus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "status",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtSplitPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "first_owner",
            type: "pubkey"
          },
          {
            name: "second_owner",
            type: "pubkey"
          },
          {
            name: "first_position",
            type: "pubkey"
          },
          {
            name: "second_position",
            type: "pubkey"
          },
          {
            name: "current_sqrt_price",
            type: "u128"
          },
          {
            name: "amount_splits",
            type: {
              defined: {
                name: "SplitAmountInfo"
              }
            }
          },
          {
            name: "first_position_info",
            type: {
              defined: {
                name: "SplitPositionInfo"
              }
            }
          },
          {
            name: "second_position_info",
            type: {
              defined: {
                name: "SplitPositionInfo"
              }
            }
          },
          {
            name: "split_position_parameters",
            type: {
              defined: {
                name: "SplitPositionParameters"
              }
            }
          }
        ]
      }
    },
    {
      name: "EvtSwap",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "trade_direction",
            type: "u8"
          },
          {
            name: "has_referral",
            type: "bool"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "SwapParameters"
              }
            }
          },
          {
            name: "swap_result",
            type: {
              defined: {
                name: "SwapResult"
              }
            }
          },
          {
            name: "actual_amount_in",
            type: "u64"
          },
          {
            name: "current_timestamp",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardDuration",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_reward_duration",
            type: "u64"
          },
          {
            name: "new_reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardFunder",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_funder",
            type: "pubkey"
          },
          {
            name: "new_funder",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtWithdrawIneligibleReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "InitializeCustomizablePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "pool fees"
            ],
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "has_alpha_vault",
            docs: [
              "has alpha vault"
            ],
            type: "bool"
          },
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value"
            ],
            type: "u128"
          },
          {
            name: "activation_type",
            docs: [
              "activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "InitializePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "Pool",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesStruct"
              }
            }
          },
          {
            name: "token_a_mint",
            docs: [
              "token a mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            docs: [
              "token b mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_a_vault",
            docs: [
              "token a vault"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_vault",
            docs: [
              "token b vault"
            ],
            type: "pubkey"
          },
          {
            name: "whitelisted_vault",
            docs: [
              "Whitelisted vault to be able to buy pool before activation_point"
            ],
            type: "pubkey"
          },
          {
            name: "partner",
            docs: [
              "partner"
            ],
            type: "pubkey"
          },
          {
            name: "liquidity",
            docs: [
              "liquidity share"
            ],
            type: "u128"
          },
          {
            name: "_padding",
            docs: [
              "padding, previous reserve amount, be careful to use that field"
            ],
            type: "u128"
          },
          {
            name: "protocol_a_fee",
            docs: [
              "protocol a fee"
            ],
            type: "u64"
          },
          {
            name: "protocol_b_fee",
            docs: [
              "protocol b fee"
            ],
            type: "u64"
          },
          {
            name: "partner_a_fee",
            docs: [
              "partner a fee"
            ],
            type: "u64"
          },
          {
            name: "partner_b_fee",
            docs: [
              "partner b fee"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "max price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "current price"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "Activation point, can be slot or timestamp"
            ],
            type: "u64"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type, 0 means by slot, 1 means by timestamp"
            ],
            type: "u8"
          },
          {
            name: "pool_status",
            docs: [
              "pool status, 0: enable, 1 disable"
            ],
            type: "u8"
          },
          {
            name: "token_a_flag",
            docs: [
              "token a flag"
            ],
            type: "u8"
          },
          {
            name: "token_b_flag",
            docs: [
              "token b flag"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "0 is collect fee in both token, 1 only collect fee in token a, 2 only collect fee in token b"
            ],
            type: "u8"
          },
          {
            name: "pool_type",
            docs: [
              "pool type"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                2
              ]
            }
          },
          {
            name: "fee_a_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "permanent_lock_liquidity",
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PoolMetrics"
              }
            }
          },
          {
            name: "creator",
            docs: [
              "pool creator"
            ],
            type: "pubkey"
          },
          {
            name: "_padding_1",
            docs: [
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                6
              ]
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "RewardInfo"
                  }
                },
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeeParameters",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Base fee"
            ],
            type: {
              defined: {
                name: "BaseFeeParameters"
              }
            }
          },
          {
            name: "padding",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                3
              ]
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              option: {
                defined: {
                  name: "DynamicFeeParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            type: {
              defined: {
                name: "BaseFeeConfig"
              }
            }
          },
          {
            name: "dynamic_fee",
            type: {
              defined: {
                name: "DynamicFeeConfig"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u64",
                5
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesStruct",
      docs: [
        "Information regarding fee charges",
        "trading_fee = amount * trade_fee_numerator / denominator",
        "protocol_fee = trading_fee * protocol_fee_percentage / 100",
        "referral_fee = protocol_fee * referral_percentage / 100",
        "partner_fee = (protocol_fee - referral_fee) * partner_fee_percentage / denominator"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Trade fees are extra token amounts that are held inside the token",
              "accounts during a trade, making the value of liquidity tokens rise.",
              "Trade fee numerator"
            ],
            type: {
              defined: {
                name: "BaseFeeStruct"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            docs: [
              "Protocol trading fees are extra token amounts that are held inside the token",
              "accounts during a trade, with the equivalent in pool tokens minted to",
              "the protocol of the program.",
              "Protocol trade fee numerator"
            ],
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            docs: [
              "partner fee"
            ],
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            docs: [
              "referral fee"
            ],
            type: "u8"
          },
          {
            name: "padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              defined: {
                name: "DynamicFeeStruct"
              }
            }
          },
          {
            name: "padding_1",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u64",
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_lp_a_fee",
            type: "u128"
          },
          {
            name: "total_lp_b_fee",
            type: "u128"
          },
          {
            name: "total_protocol_a_fee",
            type: "u64"
          },
          {
            name: "total_protocol_b_fee",
            type: "u64"
          },
          {
            name: "total_partner_a_fee",
            type: "u64"
          },
          {
            name: "total_partner_b_fee",
            type: "u64"
          },
          {
            name: "total_position",
            type: "u64"
          },
          {
            name: "padding",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Position",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "nft_mint",
            docs: [
              "nft mint"
            ],
            type: "pubkey"
          },
          {
            name: "fee_a_per_token_checkpoint",
            docs: [
              "fee a checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_token_checkpoint",
            docs: [
              "fee b checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_a_pending",
            docs: [
              "fee a pending"
            ],
            type: "u64"
          },
          {
            name: "fee_b_pending",
            docs: [
              "fee b pending"
            ],
            type: "u64"
          },
          {
            name: "unlocked_liquidity",
            docs: [
              "unlock liquidity"
            ],
            type: "u128"
          },
          {
            name: "vested_liquidity",
            docs: [
              "vesting liquidity"
            ],
            type: "u128"
          },
          {
            name: "permanent_locked_liquidity",
            docs: [
              "permanent locked liquidity"
            ],
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PositionMetrics"
              }
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "UserRewardInfo"
                  }
                },
                2
              ]
            }
          },
          {
            name: "padding",
            docs: [
              "padding for future usage"
            ],
            type: {
              array: [
                "u128",
                6
              ]
            }
          }
        ]
      }
    },
    {
      name: "PositionMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_claimed_a_fee",
            type: "u64"
          },
          {
            name: "total_claimed_b_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "minimum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "minimum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RewardInfo",
      docs: [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            docs: [
              "Indicates if the reward has been initialized"
            ],
            type: "u8"
          },
          {
            name: "reward_token_flag",
            docs: [
              "reward token flag"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "_padding_1",
            docs: [
              "Padding to ensure `reward_rate: u128` is 16-byte aligned"
            ],
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "mint",
            docs: [
              "Reward token mint."
            ],
            type: "pubkey"
          },
          {
            name: "vault",
            docs: [
              "Reward vault token account."
            ],
            type: "pubkey"
          },
          {
            name: "funder",
            docs: [
              "Authority account that allows to fund rewards"
            ],
            type: "pubkey"
          },
          {
            name: "reward_duration",
            docs: [
              "reward duration"
            ],
            type: "u64"
          },
          {
            name: "reward_duration_end",
            docs: [
              "reward duration end"
            ],
            type: "u64"
          },
          {
            name: "reward_rate",
            docs: [
              "reward rate"
            ],
            type: "u128"
          },
          {
            name: "reward_per_token_stored",
            docs: [
              "Reward per token stored"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "last_update_time",
            docs: [
              "The last time reward states were updated."
            ],
            type: "u64"
          },
          {
            name: "cumulative_seconds_with_empty_liquidity_reward",
            docs: [
              "Accumulated seconds when the farm distributed rewards but the bin was empty.",
              "These rewards will be carried over to the next reward time window."
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitAmountInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "permanent_locked_liquidity",
            type: "u128"
          },
          {
            name: "unlocked_liquidity",
            type: "u128"
          },
          {
            name: "fee_a",
            type: "u64"
          },
          {
            name: "fee_b",
            type: "u64"
          },
          {
            name: "reward_0",
            type: "u64"
          },
          {
            name: "reward_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitPositionInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity",
            type: "u128"
          },
          {
            name: "fee_a",
            type: "u64"
          },
          {
            name: "fee_b",
            type: "u64"
          },
          {
            name: "reward_0",
            type: "u64"
          },
          {
            name: "reward_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SplitPositionParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "unlocked_liquidity_percentage",
            docs: [
              "Percentage of unlocked liquidity to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "permanent_locked_liquidity_percentage",
            docs: [
              "Percentage of permanent locked liquidity to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "fee_a_percentage",
            docs: [
              "Percentage of fee A pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "fee_b_percentage",
            docs: [
              "Percentage of fee B pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "reward_0_percentage",
            docs: [
              "Percentage of reward 0 pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "reward_1_percentage",
            docs: [
              "Percentage of reward 1 pending to split to the second position"
            ],
            type: "u8"
          },
          {
            name: "padding",
            docs: [
              "padding for future"
            ],
            type: {
              array: [
                "u8",
                16
              ]
            }
          }
        ]
      }
    },
    {
      name: "StaticConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "SwapParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "minimum_amount_out",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapResult",
      docs: [
        "Encodes all results of swapping"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "output_amount",
            type: "u64"
          },
          {
            name: "next_sqrt_price",
            type: "u128"
          },
          {
            name: "lp_fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "partner_fee",
            type: "u64"
          },
          {
            name: "referral_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenBadge",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            docs: [
              "token mint"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "UserRewardInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "reward_per_token_checkpoint",
            docs: [
              "The latest update reward checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "reward_pendings",
            docs: [
              "Current pending rewards"
            ],
            type: "u64"
          },
          {
            name: "total_claimed_rewards",
            docs: [
              "Total claimed rewards"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Vesting",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "total_released_liquidity",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                14
              ]
            }
          },
          {
            name: "padding2",
            type: {
              array: [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      name: "VestingParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_point",
            type: {
              option: "u64"
            }
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    }
  ]
};

// src/CpAmm.ts
import {
  Transaction,
  SystemProgram as SystemProgram2
} from "@solana/web3.js";

// src/types.ts
var Rounding = /* @__PURE__ */ ((Rounding2) => {
  Rounding2[Rounding2["Up"] = 0] = "Up";
  Rounding2[Rounding2["Down"] = 1] = "Down";
  return Rounding2;
})(Rounding || {});
var ActivationPoint = /* @__PURE__ */ ((ActivationPoint2) => {
  ActivationPoint2[ActivationPoint2["Timestamp"] = 0] = "Timestamp";
  ActivationPoint2[ActivationPoint2["Slot"] = 1] = "Slot";
  return ActivationPoint2;
})(ActivationPoint || {});
var FeeSchedulerMode = /* @__PURE__ */ ((FeeSchedulerMode2) => {
  FeeSchedulerMode2[FeeSchedulerMode2["Linear"] = 0] = "Linear";
  FeeSchedulerMode2[FeeSchedulerMode2["Exponential"] = 1] = "Exponential";
  return FeeSchedulerMode2;
})(FeeSchedulerMode || {});
var CollectFeeMode = /* @__PURE__ */ ((CollectFeeMode2) => {
  CollectFeeMode2[CollectFeeMode2["BothToken"] = 0] = "BothToken";
  CollectFeeMode2[CollectFeeMode2["OnlyB"] = 1] = "OnlyB";
  return CollectFeeMode2;
})(CollectFeeMode || {});
var TradeDirection = /* @__PURE__ */ ((TradeDirection2) => {
  TradeDirection2[TradeDirection2["AtoB"] = 0] = "AtoB";
  TradeDirection2[TradeDirection2["BtoA"] = 1] = "BtoA";
  return TradeDirection2;
})(TradeDirection || {});
var ActivationType = /* @__PURE__ */ ((ActivationType2) => {
  ActivationType2[ActivationType2["Slot"] = 0] = "Slot";
  ActivationType2[ActivationType2["Timestamp"] = 1] = "Timestamp";
  return ActivationType2;
})(ActivationType || {});

// src/pda.ts
import { PublicKey as PublicKey2 } from "@solana/web3.js";

// src/constants.ts
import { BN } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
var CP_AMM_PROGRAM_ID = new PublicKey(
  "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG"
);
var LIQUIDITY_SCALE = 128;
var SCALE_OFFSET = 64;
var BASIS_POINT_MAX = 1e4;
var MAX_FEE_NUMERATOR = 5e8;
var FEE_DENOMINATOR = 1e9;
var MIN_SQRT_PRICE = new BN("4295048016");
var MAX_SQRT_PRICE = new BN("79226673521066979257578248091");
var MIN_CU_BUFFER = 5e4;
var MAX_CU_BUFFER = 2e5;
var DYNAMIC_FEE_FILTER_PERIOD_DEFAULT = 10;
var DYNAMIC_FEE_DECAY_PERIOD_DEFAULT = 120;
var DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT = 5e3;
var BIN_STEP_BPS_DEFAULT = 1;
var BIN_STEP_BPS_U128_DEFAULT = new BN("1844674407370955");
var MAX_PRICE_CHANGE_BPS_DEFAULT = 1500;

// src/pda.ts
function getFirstKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf1;
  }
  return buf2;
}
function getSecondKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf2;
  }
  return buf1;
}
function derivePoolAuthority() {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("pool_authority")],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveConfigAddress(index) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("config"), index.toArrayLike(Buffer, "le", 8)],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePoolAddress(config, tokenAMint, tokenBMint) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from("pool"),
      config.toBuffer(),
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint)
    ],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePositionAddress(positionNft) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("position"), positionNft.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveTokenVaultAddress(tokenMint, pool) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("token_vault"), tokenMint.toBuffer(), pool.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveRewardVaultAddress(pool, rewardIndex) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("reward_vault"), pool.toBuffer(), Buffer.from([rewardIndex])],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveCustomizablePoolAddress(tokenAMint, tokenBMint) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from("cpool"),
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint)
    ],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveTokenBadgeAddress(tokenMint) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("token_badge"), tokenMint.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function deriveClaimFeeOperatorAddress(operator) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("cf_operator"), operator.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}
function derivePositionNftAccount(positionNftMint) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from("position_nft_account"), positionNftMint.toBuffer()],
    CP_AMM_PROGRAM_ID
  )[0];
}

// src/helpers/token.ts
import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";
import {
  AccountLayout,
  createAssociatedTokenAccountIdempotentInstruction,
  createCloseAccountInstruction,
  getAccount,
  getAssociatedTokenAddressSync,
  getMint,
  NATIVE_MINT,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  TokenAccountNotFoundError,
  TokenInvalidAccountOwnerError
} from "@solana/spl-token";
import {
  SystemProgram,
  TransactionInstruction
} from "@solana/web3.js";
function getTokenProgram(flag) {
  return flag == 0 ? TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
}
var getTokenDecimals = (connection, mint) => __async(null, null, function* () {
  return (yield getMint(connection, mint)).decimals;
});
var getOrCreateATAInstruction = (_0, _1, _2, ..._3) => __async(null, [_0, _1, _2, ..._3], function* (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true, tokenProgram) {
  const toAccount = getAssociatedTokenAddressSync(
    tokenMint,
    owner,
    allowOwnerOffCurve,
    tokenProgram
  );
  try {
    yield getAccount(connection, toAccount);
    return { ataPubkey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof TokenAccountNotFoundError || e instanceof TokenInvalidAccountOwnerError) {
      const ix = createAssociatedTokenAccountIdempotentInstruction(
        payer,
        toAccount,
        owner,
        tokenMint,
        tokenProgram
      );
      return { ataPubkey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
});
var wrapSOLInstruction = (from, to, amount) => {
  return [
    SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = (_0, ..._1) => __async(null, [_0, ..._1], function* (owner, receiver = owner, allowOwnerOffCurve = true) {
  const wSolATAAccount = getAssociatedTokenAddressSync(
    NATIVE_MINT,
    owner,
    allowOwnerOffCurve
  );
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      receiver,
      owner,
      [],
      TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
});
function getAllUserPositionNftAccount(connection, user) {
  return __async(this, null, function* () {
    const filters = [
      {
        memcmp: {
          offset: 32,
          bytes: user.toBase58()
        }
      },
      {
        memcmp: {
          offset: 64,
          bytes: bs58.encode(Buffer.from([1, 0, 0, 0, 0, 0, 0, 0]))
          // 1
        }
      }
    ];
    const tokenAccountsRaw = yield connection.getProgramAccounts(
      TOKEN_2022_PROGRAM_ID,
      {
        filters
      }
    );
    const userPositionNftAccount = [];
    for (const { account, pubkey } of tokenAccountsRaw) {
      const tokenAccountData = AccountLayout.decode(account.data);
      userPositionNftAccount.push({
        positionNft: tokenAccountData.mint,
        positionNftAccount: pubkey
      });
    }
    return userPositionNftAccount;
  });
}
function getAllPositionNftAccountByOwner(connection, user) {
  return __async(this, null, function* () {
    const tokenAccounts = yield connection.getTokenAccountsByOwner(user, {
      programId: TOKEN_2022_PROGRAM_ID
    });
    const userPositionNftAccount = [];
    for (const { account, pubkey } of tokenAccounts.value) {
      const tokenAccountData = AccountLayout.decode(account.data);
      if (tokenAccountData.amount.toString() === "1") {
        userPositionNftAccount.push({
          positionNft: tokenAccountData.mint,
          positionNftAccount: pubkey
        });
      }
    }
    return userPositionNftAccount;
  });
}

// src/helpers/fee.ts
import { BN as BN5 } from "@coral-xyz/anchor";

// src/math/feeMath.ts
import { BN as BN2 } from "@coral-xyz/anchor";
var MAX_EXPONENTIAL = new BN2(524288);
var ONE = new BN2(1).shln(SCALE_OFFSET);
var MAX = new BN2(2).pow(new BN2(128)).sub(new BN2(1));
function pow(base, exp) {
  let invert = exp.isNeg();
  if (exp.isZero()) {
    return ONE;
  }
  exp = invert ? exp.abs() : exp;
  if (exp.gt(MAX_EXPONENTIAL)) {
    return new BN2(0);
  }
  let squaredBase = base;
  let result = ONE;
  if (squaredBase.gte(result)) {
    squaredBase = MAX.div(squaredBase);
    invert = !invert;
  }
  if (!exp.and(new BN2(1)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(2)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(4)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(8)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(16)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(32)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(64)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(128)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(256)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(512)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(1024)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(2048)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(4096)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(8192)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(16384)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(32768)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(65536)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(131072)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  squaredBase = squaredBase.mul(squaredBase).shrn(SCALE_OFFSET);
  if (!exp.and(new BN2(262144)).isZero()) {
    result = result.mul(squaredBase).shrn(SCALE_OFFSET);
  }
  if (result.isZero()) {
    return new BN2(0);
  }
  if (invert) {
    result = MAX.div(result);
  }
  return result;
}

// src/math/mathUtils.ts
import { BN as BN3 } from "@coral-xyz/anchor";
import Decimal from "decimal.js";
function mulDiv(x, y, denominator, rounding) {
  const { div, mod } = x.mul(y).divmod(denominator);
  if (rounding == 0 /* Up */ && !mod.isZero()) {
    return div.add(new BN3(1));
  }
  return div;
}
function q64ToDecimal(num, decimalPlaces) {
  return new Decimal(num.toString()).div(Decimal.pow(2, 64)).toDecimalPlaces(decimalPlaces);
}
function decimalToQ64(num) {
  return new BN3(num.mul(Decimal.pow(2, 64)).floor().toFixed());
}

// src/helpers/curve.ts
import { BN as BN4 } from "@coral-xyz/anchor";
function getNextSqrtPrice(amount, sqrtPrice, liquidity, aToB) {
  let result;
  if (aToB) {
    const product = amount.mul(sqrtPrice);
    const denominator = liquidity.add(product);
    const numerator = liquidity.mul(sqrtPrice);
    result = numerator.add(denominator.sub(new BN4(1))).div(denominator);
  } else {
    const quotient = amount.shln(SCALE_OFFSET * 2).div(liquidity);
    result = sqrtPrice.add(quotient);
  }
  return result;
}
function getLiquidityDeltaFromAmountA(amountA, lowerSqrtPrice, upperSqrtPrice) {
  const product = amountA.mul(lowerSqrtPrice).mul(upperSqrtPrice);
  const denominator = upperSqrtPrice.sub(lowerSqrtPrice);
  return product.div(denominator);
}
function getLiquidityDeltaFromAmountB(amountB, lowerSqrtPrice, upperSqrtPrice) {
  const denominator = upperSqrtPrice.sub(lowerSqrtPrice);
  const product = amountB.shln(128);
  return product.div(denominator);
}
function getAmountAFromLiquidityDelta(liquidity, currentSqrtPrice, maxSqrtPrice, rounding) {
  const product = liquidity.mul(maxSqrtPrice.sub(currentSqrtPrice));
  const denominator = currentSqrtPrice.mul(maxSqrtPrice);
  if (rounding == 0 /* Up */) {
    return product.add(denominator.sub(new BN4(1))).div(denominator);
  }
  return product.div(denominator);
}
function getAmountBFromLiquidityDelta(liquidity, currentSqrtPrice, minSqrtPrice, rounding) {
  const one = new BN4(1).shln(128);
  const deltaPrice = currentSqrtPrice.sub(minSqrtPrice);
  const result = liquidity.mul(deltaPrice);
  if (rounding == 0 /* Up */) {
    return result.add(one.sub(new BN4(1))).div(one);
  }
  return result.shrn(128);
}
function getNextSqrtPriceFromAmountBRoundingUp(sqrtPrice, liquidity, amount) {
  const quotient = amount.shln(128).add(liquidity).sub(new BN4(1)).div(liquidity);
  const result = sqrtPrice.sub(quotient);
  if (result.isNeg()) {
    throw new Error("sqrt price cannot be negative");
  }
  return result;
}
function getNextSqrtPriceFromAmountARoundingDown(sqrtPrice, liquidity, amount) {
  if (amount.isZero()) {
    return sqrtPrice;
  }
  const product = amount.mul(sqrtPrice);
  const denominator = liquidity.sub(product);
  if (denominator.isNeg() || denominator.isZero()) {
    throw new Error("Invalid denominator in sqrt price calculation");
  }
  const numerator = liquidity.mul(sqrtPrice);
  const result = numerator.div(denominator);
  return result;
}
function getNextSqrtPriceFromOutput(sqrtPrice, liquidity, outAmount, isB) {
  if (sqrtPrice.isZero()) {
    throw new Error("sqrt price must be greater than 0");
  }
  if (isB) {
    return getNextSqrtPriceFromAmountBRoundingUp(
      sqrtPrice,
      liquidity,
      outAmount
    );
  } else {
    return getNextSqrtPriceFromAmountARoundingDown(
      sqrtPrice,
      liquidity,
      outAmount
    );
  }
}

// src/helpers/fee.ts
import Decimal2 from "decimal.js";
function getBaseFeeNumerator(feeSchedulerMode, cliffFeeNumerator, period, reductionFactor) {
  let feeNumerator;
  if (feeSchedulerMode == 0 /* Linear */) {
    feeNumerator = cliffFeeNumerator.sub(period.mul(reductionFactor));
  } else {
    const bps = reductionFactor.shln(SCALE_OFFSET).div(new BN5(BASIS_POINT_MAX));
    const base = ONE.sub(bps);
    const result = pow(base, period);
    feeNumerator = cliffFeeNumerator.mul(result).shrn(SCALE_OFFSET);
  }
  return feeNumerator;
}
function getDynamicFeeNumerator(volatilityAccumulator, binStep, variableFeeControl) {
  if (variableFeeControl.isZero()) {
    return new BN5(0);
  }
  const squareVfaBin = volatilityAccumulator.mul(new BN5(binStep)).pow(new BN5(2));
  const vFee = variableFeeControl.mul(squareVfaBin);
  return vFee.add(new BN5(99999999999)).div(new BN5(1e11));
}
function getFeeNumerator(currentPoint, activationPoint, numberOfPeriod, periodFrequency, feeSchedulerMode, cliffFeeNumerator, reductionFactor, dynamicFeeParams) {
  if (Number(periodFrequency) == 0 || new BN5(currentPoint).lt(activationPoint)) {
    return cliffFeeNumerator;
  }
  const period = BN5.min(
    new BN5(numberOfPeriod),
    new BN5(currentPoint).sub(activationPoint).div(periodFrequency)
  );
  let feeNumerator = getBaseFeeNumerator(
    feeSchedulerMode,
    cliffFeeNumerator,
    period,
    reductionFactor
  );
  if (dynamicFeeParams) {
    const { volatilityAccumulator, binStep, variableFeeControl } = dynamicFeeParams;
    const dynamicFeeNumberator = getDynamicFeeNumerator(
      volatilityAccumulator,
      new BN5(binStep),
      new BN5(variableFeeControl)
    );
    feeNumerator = feeNumerator.add(dynamicFeeNumberator);
  }
  return feeNumerator.gt(new BN5(MAX_FEE_NUMERATOR)) ? new BN5(MAX_FEE_NUMERATOR) : feeNumerator;
}
function getFeeMode(collectFeeMode, btoA) {
  const feeOnInput = btoA && collectFeeMode === 1 /* OnlyB */;
  const feesOnTokenA = btoA && collectFeeMode === 0 /* BothToken */;
  return {
    feeOnInput,
    feesOnTokenA
  };
}
function getTotalFeeOnAmount(amount, tradeFeeNumerator) {
  return mulDiv(
    amount,
    tradeFeeNumerator,
    new BN5(FEE_DENOMINATOR),
    0 /* Up */
  );
}
function getSwapAmount(inAmount, sqrtPrice, liquidity, tradeFeeNumerator, aToB, collectFeeMode) {
  let feeMode = getFeeMode(collectFeeMode, !aToB);
  let actualInAmount = inAmount;
  let totalFee = new BN5(0);
  if (feeMode.feeOnInput) {
    totalFee = getTotalFeeOnAmount(inAmount, tradeFeeNumerator);
    actualInAmount = inAmount.sub(totalFee);
  }
  const nextSqrtPrice = getNextSqrtPrice(
    actualInAmount,
    sqrtPrice,
    liquidity,
    aToB
  );
  const outAmount = aToB ? getAmountBFromLiquidityDelta(
    liquidity,
    sqrtPrice,
    nextSqrtPrice,
    1 /* Down */
  ) : getAmountAFromLiquidityDelta(
    liquidity,
    sqrtPrice,
    nextSqrtPrice,
    1 /* Down */
  );
  const amountOut = feeMode.feeOnInput ? outAmount : (totalFee = getTotalFeeOnAmount(outAmount, tradeFeeNumerator), outAmount.sub(totalFee));
  return { amountOut, totalFee, nextSqrtPrice };
}
function bpsToFeeNumerator(bps) {
  return new BN5(bps * FEE_DENOMINATOR).divn(BASIS_POINT_MAX);
}
function feeNumeratorToBps(feeNumerator) {
  return feeNumerator.muln(BASIS_POINT_MAX).div(new BN5(FEE_DENOMINATOR)).toNumber();
}
function getBaseFeeParams(maxBaseFeeBps, minBaseFeeBps, feeSchedulerMode, numberOfPeriod, totalDuration) {
  if (maxBaseFeeBps == minBaseFeeBps) {
    if (numberOfPeriod != 0 || totalDuration != 0) {
      throw new Error("numberOfPeriod and totalDuration must both be zero");
    }
    return {
      cliffFeeNumerator: bpsToFeeNumerator(maxBaseFeeBps),
      numberOfPeriod: 0,
      periodFrequency: new BN5(0),
      reductionFactor: new BN5(0),
      feeSchedulerMode: 0
    };
  }
  if (numberOfPeriod <= 0) {
    throw new Error("Total periods must be greater than zero");
  }
  if (maxBaseFeeBps > feeNumeratorToBps(new BN5(MAX_FEE_NUMERATOR))) {
    throw new Error(
      `maxBaseFeeBps (${maxBaseFeeBps} bps) exceeds maximum allowed value of ${feeNumeratorToBps(
        new BN5(MAX_FEE_NUMERATOR)
      )} bps`
    );
  }
  if (minBaseFeeBps > maxBaseFeeBps) {
    throw new Error(
      "minBaseFee bps must be less than or equal to maxBaseFee bps"
    );
  }
  if (numberOfPeriod == 0 || totalDuration == 0) {
    throw new Error(
      "numberOfPeriod and totalDuration must both greater than zero"
    );
  }
  const maxBaseFeeNumerator = bpsToFeeNumerator(maxBaseFeeBps);
  const minBaseFeeNumerator = bpsToFeeNumerator(minBaseFeeBps);
  const periodFrequency = new BN5(totalDuration / numberOfPeriod);
  let reductionFactor;
  if (feeSchedulerMode == 0 /* Linear */) {
    const totalReduction = maxBaseFeeNumerator.sub(minBaseFeeNumerator);
    reductionFactor = totalReduction.divn(numberOfPeriod);
  } else {
    const ratio = minBaseFeeNumerator.toNumber() / maxBaseFeeNumerator.toNumber();
    const decayBase = Math.pow(ratio, 1 / numberOfPeriod);
    reductionFactor = new BN5(BASIS_POINT_MAX * (1 - decayBase));
  }
  return {
    cliffFeeNumerator: maxBaseFeeNumerator,
    numberOfPeriod,
    periodFrequency,
    reductionFactor,
    feeSchedulerMode
  };
}
function getDynamicFeeParams(baseFeeBps, maxPriceChangeBps = MAX_PRICE_CHANGE_BPS_DEFAULT) {
  if (maxPriceChangeBps > MAX_PRICE_CHANGE_BPS_DEFAULT) {
    throw new Error(
      `maxPriceChangeBps (${maxPriceChangeBps} bps) must be less than or equal to ${MAX_PRICE_CHANGE_BPS_DEFAULT}`
    );
  }
  const priceRatio = maxPriceChangeBps / BASIS_POINT_MAX + 1;
  const sqrtPriceRatioQ64 = new BN5(
    Decimal2.sqrt(priceRatio.toString()).mul(Decimal2.pow(2, 64)).floor().toFixed()
  );
  const deltaBinId = sqrtPriceRatioQ64.sub(ONE).div(BIN_STEP_BPS_U128_DEFAULT).muln(2);
  const maxVolatilityAccumulator = new BN5(deltaBinId.muln(BASIS_POINT_MAX));
  const squareVfaBin = maxVolatilityAccumulator.mul(new BN5(BIN_STEP_BPS_DEFAULT)).pow(new BN5(2));
  const baseFeeNumerator = new BN5(bpsToFeeNumerator(baseFeeBps));
  const maxDynamicFeeNumerator = baseFeeNumerator.muln(20).divn(100);
  const vFee = maxDynamicFeeNumerator.mul(new BN5(1e11)).sub(new BN5(99999999999));
  const variableFeeControl = vFee.div(squareVfaBin);
  return {
    binStep: BIN_STEP_BPS_DEFAULT,
    binStepU128: BIN_STEP_BPS_U128_DEFAULT,
    filterPeriod: DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
    decayPeriod: DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
    reductionFactor: DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
    maxVolatilityAccumulator: maxVolatilityAccumulator.toNumber(),
    variableFeeControl: variableFeeControl.toNumber()
  };
}
function getExcludedFeeAmount(tradeFeeNumerator, includedFeeAmount) {
  const tradingFee = mulDiv(
    includedFeeAmount,
    tradeFeeNumerator,
    new BN5(FEE_DENOMINATOR),
    0 /* Up */
  );
  const excludedFeeAmount = includedFeeAmount.sub(tradingFee);
  return { excludedFeeAmount, tradingFee };
}
function getIncludedFeeAmount(tradeFeeNumerator, excludedFeeAmount) {
  const denominator = new BN5(FEE_DENOMINATOR).sub(tradeFeeNumerator);
  if (denominator.isZero() || denominator.isNeg()) {
    throw new Error("Invalid fee numerator");
  }
  const includedFeeAmount = mulDiv(
    excludedFeeAmount,
    new BN5(FEE_DENOMINATOR),
    denominator,
    0 /* Up */
  );
  const { excludedFeeAmount: inverseAmount } = getExcludedFeeAmount(
    tradeFeeNumerator,
    includedFeeAmount
  );
  if (inverseAmount.lt(excludedFeeAmount)) {
    throw new Error("Inverse amount is less than excluded_fee_amount");
  }
  return includedFeeAmount;
}
function getInAmountFromAToB(pool, outAmount) {
  const nextSqrtPrice = getNextSqrtPriceFromOutput(
    pool.sqrtPrice,
    pool.liquidity,
    outAmount,
    true
  );
  if (nextSqrtPrice.lt(pool.sqrtMinPrice)) {
    throw new Error("Price range is violated");
  }
  const outputAmount = getAmountAFromLiquidityDelta(
    pool.liquidity,
    nextSqrtPrice,
    pool.sqrtPrice,
    0 /* Up */
  );
  return {
    outputAmount,
    nextSqrtPrice
  };
}
function getInAmountFromBToA(pool, outAmount) {
  const nextSqrtPrice = getNextSqrtPriceFromOutput(
    pool.sqrtPrice,
    pool.liquidity,
    outAmount,
    false
  );
  if (nextSqrtPrice.gt(pool.sqrtMaxPrice)) {
    throw new Error("Price range is violated");
  }
  const outputAmount = getAmountBFromLiquidityDelta(
    pool.liquidity,
    pool.sqrtPrice,
    nextSqrtPrice,
    0 /* Up */
  );
  return {
    outputAmount,
    nextSqrtPrice
  };
}
function getSwapResultFromOutAmount(pool, outAmount, feeMode, tradeDirection, currentPoint) {
  let actualProtocolFee = new BN5(0);
  let actualLpFee = new BN5(0);
  let actualPartnerFee = new BN5(0);
  let actualReferralFee = new BN5(0);
  const tradeFeeNumerator = getFeeNumerator(
    currentPoint,
    pool.activationPoint,
    pool.poolFees.baseFee.numberOfPeriod,
    pool.poolFees.baseFee.periodFrequency,
    pool.poolFees.baseFee.feeSchedulerMode,
    pool.poolFees.baseFee.cliffFeeNumerator,
    pool.poolFees.baseFee.reductionFactor,
    pool.poolFees.dynamicFee.initialized === 1 ? {
      volatilityAccumulator: pool.poolFees.dynamicFee.volatilityAccumulator,
      binStep: pool.poolFees.dynamicFee.binStep,
      variableFeeControl: pool.poolFees.dynamicFee.variableFeeControl
    } : void 0
  );
  let includedFeeOutAmount;
  if (feeMode.feeOnInput) {
    includedFeeOutAmount = outAmount;
  } else {
    includedFeeOutAmount = getIncludedFeeAmount(tradeFeeNumerator, outAmount);
    const totalFee = getTotalFeeOnAmount(outAmount, tradeFeeNumerator);
    actualProtocolFee = mulDiv(
      totalFee,
      new BN5(pool.poolFees.protocolFeePercent),
      new BN5(100),
      1 /* Down */
    );
    if (feeMode.hasReferral) {
      actualReferralFee = mulDiv(
        actualProtocolFee,
        new BN5(pool.poolFees.referralFeePercent),
        new BN5(100),
        1 /* Down */
      );
    }
    const protocolFeeAfterReferral = actualProtocolFee.sub(actualReferralFee);
    actualPartnerFee = mulDiv(
      protocolFeeAfterReferral,
      new BN5(pool.poolFees.partnerFeePercent),
      new BN5(100),
      1 /* Down */
    );
    actualLpFee = totalFee.sub(actualProtocolFee).sub(actualPartnerFee);
  }
  const { outputAmount: excludedFeeInAmount, nextSqrtPrice } = tradeDirection === 0 /* AtoB */ ? getInAmountFromAToB(pool, includedFeeOutAmount) : getInAmountFromBToA(pool, includedFeeOutAmount);
  let includedFeeInAmount;
  if (feeMode.feeOnInput) {
    includedFeeInAmount = getIncludedFeeAmount(
      tradeFeeNumerator,
      excludedFeeInAmount
    );
    const totalFee = getTotalFeeOnAmount(
      includedFeeInAmount,
      tradeFeeNumerator
    );
    actualProtocolFee = mulDiv(
      totalFee,
      new BN5(pool.poolFees.protocolFeePercent),
      new BN5(100),
      1 /* Down */
    );
    if (feeMode.hasReferral) {
      actualReferralFee = mulDiv(
        actualProtocolFee,
        new BN5(pool.poolFees.referralFeePercent),
        new BN5(100),
        1 /* Down */
      );
    }
    const protocolFeeAfterReferral = actualProtocolFee.sub(actualReferralFee);
    actualPartnerFee = mulDiv(
      protocolFeeAfterReferral,
      new BN5(pool.poolFees.partnerFeePercent),
      new BN5(100),
      1 /* Down */
    );
    actualLpFee = totalFee.sub(actualProtocolFee).sub(actualPartnerFee);
  } else {
    includedFeeInAmount = excludedFeeInAmount;
  }
  return {
    swapResult: {
      outputAmount: outAmount,
      nextSqrtPrice,
      lpFee: actualLpFee,
      protocolFee: actualProtocolFee,
      referralFee: actualReferralFee,
      partnerFee: actualPartnerFee
    },
    inputAmount: includedFeeInAmount
  };
}

// src/helpers/computeUnits.ts
import {
  ComputeBudgetProgram,
  PublicKey as PublicKey4,
  TransactionMessage,
  VersionedTransaction
} from "@solana/web3.js";
var getSimulationComputeUnits = (connection, instructions, payer, lookupTables, commitment = "confirmed") => __async(null, null, function* () {
  var _a, _b, _c;
  const testInstructions = [
    // Set an arbitrarily high number in simulation
    // so we can be sure the transaction will succeed
    // and get the real compute units used
    ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
    ...instructions
  ];
  const testTransaction = new VersionedTransaction(
    new TransactionMessage({
      instructions: testInstructions,
      payerKey: payer,
      // RecentBlockhash can by any public key during simulation
      // since 'replaceRecentBlockhash' is set to 'true' below
      recentBlockhash: PublicKey4.default.toString()
    }).compileToV0Message(lookupTables)
  );
  const rpcResponse = yield connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false,
    commitment
  });
  if ((_a = rpcResponse == null ? void 0 : rpcResponse.value) == null ? void 0 : _a.err) {
    const logs = ((_b = rpcResponse.value.logs) == null ? void 0 : _b.join("\n  \u2022 ")) || "No logs available";
    throw new Error(
      `Transaction simulation failed:
  \u2022${logs}` + JSON.stringify((_c = rpcResponse == null ? void 0 : rpcResponse.value) == null ? void 0 : _c.err)
    );
  }
  return rpcResponse.value.unitsConsumed || null;
});
var getEstimatedComputeUnitUsageWithBuffer = (connection, instructions, feePayer, buffer) => __async(null, null, function* () {
  if (!buffer) {
    buffer = 0.1;
  }
  buffer = Math.max(0, buffer);
  buffer = Math.min(1, buffer);
  const estimatedComputeUnitUsage = yield getSimulationComputeUnits(
    connection,
    instructions,
    feePayer,
    []
  );
  if (!estimatedComputeUnitUsage) {
    return 0;
  }
  let extraComputeUnitBuffer = estimatedComputeUnitUsage * buffer;
  if (extraComputeUnitBuffer > MAX_CU_BUFFER) {
    extraComputeUnitBuffer = MAX_CU_BUFFER;
  } else if (extraComputeUnitBuffer < MIN_CU_BUFFER) {
    extraComputeUnitBuffer = MIN_CU_BUFFER;
  }
  return estimatedComputeUnitUsage + extraComputeUnitBuffer;
});
var getEstimatedComputeUnitIxWithBuffer = (connection, instructions, feePayer, buffer) => __async(null, null, function* () {
  const units = yield getEstimatedComputeUnitUsageWithBuffer(
    connection,
    instructions,
    feePayer,
    buffer
  ).catch((error) => {
    console.error("Error::getEstimatedComputeUnitUsageWithBuffer", error);
    return 14e5;
  });
  return ComputeBudgetProgram.setComputeUnitLimit({ units });
});

// src/helpers/utils.ts
import { BN as BN6 } from "@coral-xyz/anchor";
import Decimal3 from "decimal.js";
var getMaxAmountWithSlippage = (amount, rate) => {
  const slippage = (100 + rate) / 100 * BASIS_POINT_MAX;
  return amount.mul(new BN6(slippage)).div(new BN6(BASIS_POINT_MAX));
};
var getMinAmountWithSlippage = (amount, rate) => {
  const slippage = (100 - rate) / 100 * BASIS_POINT_MAX;
  return amount.mul(new BN6(slippage)).div(new BN6(BASIS_POINT_MAX));
};
var getPriceImpact = (nextSqrtPrice, currentSqrtPrice) => {
  const diff = nextSqrtPrice.pow(new BN6(2)).sub(currentSqrtPrice.pow(new BN6(2))).abs();
  return new Decimal3(diff.toString()).div(new Decimal3(currentSqrtPrice.pow(new BN6(2)).toString())).mul(100).toNumber();
};
var getPriceFromSqrtPrice = (sqrtPrice, tokenADecimal, tokenBDecimal) => {
  const decimalSqrtPrice = new Decimal3(sqrtPrice.toString());
  const price = decimalSqrtPrice.mul(decimalSqrtPrice).mul(new Decimal3(__pow(10, tokenADecimal - tokenBDecimal))).div(Decimal3.pow(2, 128)).toString();
  return price;
};
var getSqrtPriceFromPrice = (price, tokenADecimal, tokenBDecimal) => {
  const decimalPrice = new Decimal3(price);
  const adjustedByDecimals = decimalPrice.div(
    new Decimal3(__pow(10, tokenADecimal - tokenBDecimal))
  );
  const sqrtValue = Decimal3.sqrt(adjustedByDecimals);
  const sqrtValueQ64 = sqrtValue.mul(Decimal3.pow(2, 64));
  return new BN6(sqrtValueQ64.floor().toFixed());
};
var getUnClaimReward = (poolState, positionState) => {
  const totalPositionLiquidity = positionState.unlockedLiquidity.add(positionState.vestedLiquidity).add(positionState.permanentLockedLiquidity);
  const feeAPerTokenStored = new BN6(
    Buffer.from(poolState.feeAPerLiquidity).reverse()
  ).sub(new BN6(Buffer.from(positionState.feeAPerTokenCheckpoint).reverse()));
  const feeBPerTokenStored = new BN6(
    Buffer.from(poolState.feeBPerLiquidity).reverse()
  ).sub(new BN6(Buffer.from(positionState.feeBPerTokenCheckpoint).reverse()));
  const feeA = totalPositionLiquidity.mul(feeAPerTokenStored).shrn(LIQUIDITY_SCALE);
  const feeB = totalPositionLiquidity.mul(feeBPerTokenStored).shrn(LIQUIDITY_SCALE);
  return {
    feeTokenA: positionState.feeAPending.add(feeA),
    feeTokenB: positionState.feeBPending.add(feeB),
    rewards: positionState.rewardInfos.length > 0 ? positionState.rewardInfos.map((item) => item.rewardPendings) : []
  };
};

// src/helpers/accountFilters.ts
var positionByPoolFilter = (pool) => {
  return {
    memcmp: {
      bytes: pool.toBase58(),
      offset: 8
    }
  };
};
var vestingByPositionFilter = (position) => {
  return {
    memcmp: {
      bytes: position.toBase58(),
      offset: 8
    }
  };
};

// src/helpers/priceMath.ts
import { BN as BN7 } from "@coral-xyz/anchor";
import Decimal4 from "decimal.js";
function calculateInitSqrtPrice(tokenAAmount, tokenBAmount, minSqrtPrice, maxSqrtPrice) {
  if (tokenAAmount.isZero() || tokenBAmount.isZero()) {
    throw new Error("Amount cannot be zero");
  }
  const amountADecimal = new Decimal4(tokenAAmount.toString());
  const amountBDecimal = new Decimal4(tokenBAmount.toString());
  const minSqrtPriceDecimal = new Decimal4(minSqrtPrice.toString()).div(
    Decimal4.pow(2, 64)
  );
  const maxSqrtPriceDecimal = new Decimal4(maxSqrtPrice.toString()).div(
    Decimal4.pow(2, 64)
  );
  const x = new Decimal4(1).div(maxSqrtPriceDecimal);
  const y = amountBDecimal.div(amountADecimal);
  const xy = x.mul(y);
  const paMinusXY = minSqrtPriceDecimal.sub(xy);
  const xyMinusPa = xy.sub(minSqrtPriceDecimal);
  const fourY = new Decimal4(4).mul(y);
  const discriminant = xyMinusPa.mul(xyMinusPa).add(fourY);
  const sqrtDiscriminant = discriminant.sqrt();
  const result = paMinusXY.add(sqrtDiscriminant).div(new Decimal4(2)).mul(Decimal4.pow(2, 64));
  return new BN7(result.floor().toFixed());
}

// src/helpers/token2022.ts
import { BN as BN8 } from "@coral-xyz/anchor";
import {
  calculateFee,
  getEpochFee,
  getTransferFeeConfig,
  MAX_FEE_BASIS_POINTS
} from "@solana/spl-token";
function calculatePreFeeAmount(transferFee, postFeeAmount) {
  if (postFeeAmount.isZero()) {
    return new BN8(0);
  }
  if (transferFee.transferFeeBasisPoints === 0) {
    return postFeeAmount;
  }
  const maximumFee = new BN8(transferFee.maximumFee.toString());
  if (transferFee.transferFeeBasisPoints === MAX_FEE_BASIS_POINTS) {
    return postFeeAmount.add(maximumFee);
  }
  const ONE_IN_BASIS_POINTS = new BN8(MAX_FEE_BASIS_POINTS);
  const numerator = postFeeAmount.mul(ONE_IN_BASIS_POINTS);
  const denominator = ONE_IN_BASIS_POINTS.sub(
    new BN8(transferFee.transferFeeBasisPoints)
  );
  const rawPreFeeAmount = numerator.add(denominator).sub(new BN8(1)).div(denominator);
  if (rawPreFeeAmount.sub(postFeeAmount).gte(maximumFee)) {
    return postFeeAmount.add(maximumFee);
  }
  return rawPreFeeAmount;
}
function calculateInverseFee(transferFee, postFeeAmount) {
  const preFeeAmount = calculatePreFeeAmount(transferFee, postFeeAmount);
  return new BN8(
    calculateFee(transferFee, BigInt(preFeeAmount.toString())).toString()
  );
}
function calculateTransferFeeIncludedAmount(transferFeeExcludedAmount, mint, currentEpoch) {
  if (transferFeeExcludedAmount.isZero()) {
    return {
      amount: new BN8(0),
      transferFee: new BN8(0)
    };
  }
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeExcludedAmount,
      transferFee: new BN8(0)
    };
  }
  const epochFee = getEpochFee(transferFeeConfig, BigInt(currentEpoch));
  const transferFee = epochFee.transferFeeBasisPoints == MAX_FEE_BASIS_POINTS ? new BN8(epochFee.maximumFee.toString()) : calculateInverseFee(epochFee, transferFeeExcludedAmount);
  const transferFeeIncludedAmount = transferFeeExcludedAmount.add(transferFee);
  return {
    amount: transferFeeIncludedAmount,
    transferFee
  };
}
function calculateTransferFeeExcludedAmount(transferFeeIncludedAmount, mint, currentEpoch) {
  const transferFeeConfig = getTransferFeeConfig(mint);
  if (transferFeeConfig === null) {
    return {
      amount: transferFeeIncludedAmount,
      transferFee: new BN8(0)
    };
  }
  const transferFeeIncludedAmountN = BigInt(
    transferFeeIncludedAmount.toString()
  );
  const transferFee = calculateFee(
    getEpochFee(transferFeeConfig, BigInt(currentEpoch)),
    transferFeeIncludedAmountN
  );
  const transferFeeExcludedAmount = new BN8(
    (transferFeeIncludedAmountN - transferFee).toString()
  );
  return {
    amount: transferFeeExcludedAmount,
    transferFee: new BN8(transferFee.toString())
  };
}

// src/helpers/vestings.ts
import { BN as BN9 } from "@coral-xyz/anchor";
import { min } from "bn.js";
function isVestingComplete(vestingData, currentPoint) {
  const cliffPoint = vestingData.cliffPoint;
  const periodFrequency = vestingData.periodFrequency;
  const numberOfPeriods = vestingData.numberOfPeriod;
  const endPoint = cliffPoint.add(periodFrequency.muln(numberOfPeriods));
  return currentPoint.gte(endPoint);
}
function getTotalLockedLiquidity(vestingData) {
  return vestingData.cliffUnlockLiquidity.add(
    vestingData.liquidityPerPeriod.mul(new BN9(vestingData.numberOfPeriod))
  );
}
function getAvailableVestingLiquidity(vestingData, currentPoint) {
  const {
    cliffPoint,
    periodFrequency,
    cliffUnlockLiquidity,
    liquidityPerPeriod,
    numberOfPeriod,
    totalReleasedLiquidity
  } = vestingData;
  if (currentPoint.lt(cliffPoint)) {
    return new BN9(0);
  }
  if (periodFrequency.isZero()) {
    return cliffUnlockLiquidity;
  }
  let passedPeriod = new BN9(currentPoint).sub(cliffPoint).div(periodFrequency);
  passedPeriod = min(passedPeriod, new BN9(numberOfPeriod));
  const unlockedLiquidity = cliffUnlockLiquidity.add(
    passedPeriod.mul(liquidityPerPeriod)
  );
  const availableReleasingLiquidity = unlockedLiquidity.sub(
    totalReleasedLiquidity
  );
  return availableReleasingLiquidity;
}

// src/CpAmm.ts
import { min as min2, max } from "bn.js";
var CpAmm = class {
  constructor(connection) {
    this._program = new Program(cp_amm_default, {
      connection
    });
    this.poolAuthority = derivePoolAuthority();
  }
  //// ANCHOR: PRIVATE FUNCTIONS //////
  /**
   * Prepares token accounts for a transaction by retrieving or creating associated token accounts.
   * @private
   * @param {PublicKey} owner - The owner of the token accounts
   * @param {PublicKey} tokenAMint - Mint address of token A
   * @param {PublicKey} tokenBMint - Mint address of token B
   * @param {PublicKey} tokenAProgram - Program ID for token A (Token or Token2022)
   * @param {PublicKey} tokenBProgram - Program ID for token B (Token or Token2022)
   * @returns {Promise<{tokenAAta: PublicKey, tokenBAta: PublicKey, instructions: TransactionInstruction[]}>}
   *          The token account addresses and any instructions needed to create them
   */
  prepareTokenAccounts(params) {
    return __async(this, null, function* () {
      const {
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const instructions = [];
      const [
        { ataPubkey: tokenAAta, ix: createInputTokenAccountIx },
        { ataPubkey: tokenBAta, ix: createOutputTokenAccountIx }
      ] = yield Promise.all([
        getOrCreateATAInstruction(
          this._program.provider.connection,
          tokenAMint,
          tokenAOwner,
          payer,
          true,
          tokenAProgram
        ),
        getOrCreateATAInstruction(
          this._program.provider.connection,
          tokenBMint,
          tokenBOwner,
          payer,
          true,
          tokenBProgram
        )
      ]);
      createInputTokenAccountIx && instructions.push(createInputTokenAccountIx);
      createOutputTokenAccountIx && instructions.push(createOutputTokenAccountIx);
      return { tokenAAta, tokenBAta, instructions };
    });
  }
  /**
   * Derives token badge account metadata
   * @param tokenAMint - Public key of token A mint
   * @param tokenBMint - Public key of token B mint
   * @returns Array of account metadata for token badges
   */
  getTokenBadgeAccounts(tokenAMint, tokenBMint) {
    return [
      {
        pubkey: deriveTokenBadgeAddress(tokenAMint),
        isWritable: false,
        isSigner: false
      },
      {
        pubkey: deriveTokenBadgeAddress(tokenBMint),
        isWritable: false,
        isSigner: false
      }
    ];
  }
  /**
   * Builds an instruction to add liquidity to a position.
   * @private
   * @param {BuildAddLiquidityParams} params - Parameters for adding liquidity
   * @returns {Promise<TransactionInstruction>} Instruction to add liquidity
   */
  buildAddLiquidityInstruction(params) {
    return __async(this, null, function* () {
      const {
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      } = params;
      return yield this._program.methods.addLiquidity({
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      }).accountsPartial({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to remove all liquidity from a position.
   * @private
   * @param {BuildRemoveAllLiquidityInstructionParams} params - Parameters for removing all liquidity
   * @returns {Promise<TransactionInstruction>} Instruction to remove all liquidity
   */
  buildRemoveAllLiquidityInstruction(params) {
    return __async(this, null, function* () {
      const {
        poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      } = params;
      return yield this._program.methods.removeAllLiquidity(tokenAAmountThreshold, tokenBAmountThreshold).accountsPartial({
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to claim fees accumulated by a position.
   * @private
   * @param {ClaimPositionFeeInstructionParams} params - Parameters for claiming position fees
   * @returns {Promise<TransactionInstruction>} Instruction to claim position fees
   */
  buildClaimPositionFeeInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      return yield this._program.methods.claimPositionFee().accountsPartial({
        poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      }).instruction();
    });
  }
  /**
   * Builds an instruction to close a position.
   * @private
   * @param {ClosePositionInstructionParams} params - Parameters for closing a position
   * @returns {Promise<TransactionInstruction>} Instruction to close the position
   */
  buildClosePositionInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        poolAuthority,
        pool,
        position,
        positionNftAccount,
        positionNftMint
      } = params;
      return yield this._program.methods.closePosition().accountsPartial({
        positionNftMint,
        positionNftAccount,
        pool,
        position,
        poolAuthority,
        rentReceiver: owner,
        owner,
        tokenProgram: TOKEN_2022_PROGRAM_ID2
      }).instruction();
    });
  }
  /**
   * Builds an instruction to refresh vesting for a position
   * @param params Parameters required for the refresh vesting instruction
   * @returns Transaction instruction or null if no vestings to refresh
   */
  buildRefreshVestingInstruction(params) {
    return __async(this, null, function* () {
      const { owner, position, positionNftAccount, pool, vestingAccounts } = params;
      if (vestingAccounts.length == 0) {
        return null;
      }
      return yield this._program.methods.refreshVesting().accountsPartial({
        position,
        positionNftAccount,
        pool,
        owner
      }).remainingAccounts(
        vestingAccounts.map((pubkey) => {
          return {
            isSigner: false,
            isWritable: true,
            pubkey
          };
        })
      ).instruction();
    });
  }
  /**
   * Helper function that builds instructions to claim fees, remove liquidity, and close a position
   * @param {BuildLiquidatePositionInstructionParams} params - Parameters for liquidating a position
   * @returns {Promise<TransactionInstruction[]>} Array of instructions
   * @private
   */
  buildLiquidatePositionInstruction(params) {
    return __async(this, null, function* () {
      const {
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      } = params;
      const { nftMint: positionNftMint, pool } = positionState;
      const { tokenAMint, tokenBMint, tokenAVault, tokenBVault } = poolState;
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const instructions = [];
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      instructions.push(claimPositionFeeInstruction);
      const removeAllLiquidityInstruction = yield this.buildRemoveAllLiquidityInstruction({
        poolAuthority: this.poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      });
      instructions.push(removeAllLiquidityInstruction);
      const closePositionInstruction = yield this.buildClosePositionInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftMint,
        positionNftAccount
      });
      instructions.push(closePositionInstruction);
      return instructions;
    });
  }
  /**
   * Builds a instruction to create a position.
   * @param {CreatePositionParams} params - Parameters for position creation.
   * @returns Transaction instruction.
   */
  buildCreatePositionInstruction(params) {
    return __async(this, null, function* () {
      const { owner, payer, pool, positionNft } = params;
      const position = derivePositionAddress(positionNft);
      const positionNftAccount = derivePositionNftAccount(positionNft);
      const ix = yield this._program.methods.createPosition().accountsPartial({
        owner,
        positionNftMint: positionNft,
        poolAuthority: this.poolAuthority,
        positionNftAccount,
        payer,
        pool,
        position,
        tokenProgram: TOKEN_2022_PROGRAM_ID2,
        systemProgram: SystemProgram2.programId
      }).instruction();
      return {
        ix,
        position,
        positionNftAccount
      };
    });
  }
  /**
   * Private helper method to prepare common customizable pool creation logic
   * @param {PrepareCustomizablePoolParams} params - Common parameters for pool creation
   * @returns Prepared transaction data including instructions and accounts
   */
  prepareCreatePoolParams(params) {
    return __async(this, null, function* () {
      const {
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      } = params;
      const position = derivePositionAddress(positionNft);
      const positionNftAccount = derivePositionNftAccount(positionNft);
      const tokenAVault = deriveTokenVaultAddress(tokenAMint, pool);
      const tokenBVault = deriveTokenVaultAddress(tokenBMint, pool);
      const {
        tokenAAta: payerTokenA,
        tokenBAta: payerTokenB,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner: payer,
        tokenBOwner: payer,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          payer,
          payerTokenA,
          BigInt(tokenAAmount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          payer,
          payerTokenB,
          BigInt(tokenBAmount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const tokenBadgeAccounts = this.getTokenBadgeAccounts(
        tokenAMint,
        tokenBMint
      );
      return {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      };
    });
  }
  /**
   * Sets up token accounts and instructions for fee claim operations.
   * @private
   * @param {SetupFeeClaimAccountsParams} params - Parameters for setting up fee claim accounts.
   * @returns Token accounts and instructions for fee claiming.
   */
  setupFeeClaimAccounts(params) {
    return __async(this, null, function* () {
      const {
        payer,
        owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      } = params;
      const tokenAIsSOL = tokenAMint.equals(NATIVE_MINT2);
      const tokenBIsSOL = tokenBMint.equals(NATIVE_MINT2);
      const hasSolToken = tokenAIsSOL || tokenBIsSOL;
      const preInstructions = [];
      const postInstructions = [];
      let tokenAAccount;
      let tokenBAccount;
      let tokenAOwner = owner;
      let tokenBOwner = owner;
      if (receiver) {
        tokenAOwner = tokenAIsSOL ? tempWSolAccount : receiver;
        tokenBOwner = tokenBIsSOL ? tempWSolAccount : receiver;
      }
      const { tokenAAta, tokenBAta, instructions } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      tokenAAccount = tokenAAta;
      tokenBAccount = tokenBAta;
      preInstructions.push(...instructions);
      if (hasSolToken) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(
          tempWSolAccount != null ? tempWSolAccount : owner,
          receiver != null ? receiver : owner
        );
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return {
        tokenAAccount,
        tokenBAccount,
        preInstructions,
        postInstructions
      };
    });
  }
  //// ANCHOR: GETTER/FETCHER FUNCTIONS //////
  /**
   * Fetches the Config state of the program.
   * @param config - Public key of the config account.
   * @returns Parsed ConfigState.
   */
  fetchConfigState(config) {
    return __async(this, null, function* () {
      const configState = yield this._program.account.config.fetchNullable(
        config
      );
      invariant(configState, `Config account: ${config} not found`);
      return configState;
    });
  }
  /**
   * Fetches the Pool state.
   * @param pool - Public key of the pool.
   * @returns Parsed PoolState.
   */
  fetchPoolState(pool) {
    return __async(this, null, function* () {
      const poolState = yield this._program.account.pool.fetchNullable(pool);
      invariant(poolState, `Pool account: ${pool} not found`);
      return poolState;
    });
  }
  /**
   * Fetches the Position state.
   * @param position - Public key of the position.
   * @returns Parsed PositionState.
   */
  fetchPositionState(position) {
    return __async(this, null, function* () {
      const positionState = yield this._program.account.position.fetchNullable(
        position
      );
      invariant(positionState, `Position account: ${position} not found`);
      return positionState;
    });
  }
  /**
   * Retrieves all config accounts.
   * @returns Array of config public keys and their states.
   */
  getAllConfigs() {
    return __async(this, null, function* () {
      const configAccounts = yield this._program.account.config.all();
      return configAccounts;
    });
  }
  /**
   * Retrieves all pool accounts.
   * @returns Array of pool public keys and their states.
   */
  getAllPools() {
    return __async(this, null, function* () {
      const poolAccounts = yield this._program.account.pool.all();
      return poolAccounts;
    });
  }
  /**
   * Retrieves all position accounts.
   * @returns Array of position public keys and their states.
   */
  getAllPositions() {
    return __async(this, null, function* () {
      const poolAccounts = yield this._program.account.position.all();
      return poolAccounts;
    });
  }
  /**
   * Gets all positions a specific pool.
   * @param pool - Public key of the pool.
   * @returns List of user positions for the pool.
   */
  getAllPositionsByPool(pool) {
    return __async(this, null, function* () {
      return yield this._program.account.position.all([
        positionByPoolFilter(pool)
      ]);
    });
  }
  /**
   * Gets all positions of a user for a specific pool.
   * @param pool - Public key of the pool.
   * @param user - Public key of the user.
   * @returns List of user positions for the pool.
   */
  getUserPositionByPool(pool, user) {
    return __async(this, null, function* () {
      const allUserPositions = yield this.getPositionsByUser(user);
      return allUserPositions.filter(
        (position) => position.positionState.pool.equals(pool)
      );
    });
  }
  /**
   * Gets all positions of a user across all pools.
   * @param user - Public key of the user.
   * @returns Array of user positions already sorted by liquidity
   */
  getPositionsByUser(user) {
    return __async(this, null, function* () {
      const userPositionAccounts = yield getAllPositionNftAccountByOwner(
        this._program.provider.connection,
        user
      );
      if (userPositionAccounts.length === 0) {
        return [];
      }
      const positionAddresses = userPositionAccounts.map(
        (account) => derivePositionAddress(account.positionNft)
      );
      const positionStates = yield this._program.account.position.fetchMultiple(
        positionAddresses
      );
      const positionResult = userPositionAccounts.map((account, index) => {
        const positionState = positionStates[index];
        if (!positionState) return null;
        return {
          positionNftAccount: account.positionNftAccount,
          position: positionAddresses[index],
          positionState
        };
      }).filter(Boolean);
      positionResult.sort((a, b) => {
        const totalLiquidityA = a.positionState.vestedLiquidity.add(a.positionState.permanentLockedLiquidity).add(a.positionState.unlockedLiquidity);
        const totalLiquidityB = b.positionState.vestedLiquidity.add(b.positionState.permanentLockedLiquidity).add(b.positionState.unlockedLiquidity);
        return totalLiquidityB.cmp(totalLiquidityA);
      });
      return positionResult;
    });
  }
  getAllVestingsByPosition(position) {
    return __async(this, null, function* () {
      const vestings = yield this._program.account.vesting.all([
        vestingByPositionFilter(position)
      ]);
      return vestings;
    });
  }
  isLockedPosition(position) {
    const totalLockedLiquidity = position.vestedLiquidity.add(
      position.permanentLockedLiquidity
    );
    return totalLockedLiquidity.gtn(0);
  }
  isPermanentLockedPosition(positionState) {
    return positionState.permanentLockedLiquidity.gtn(0);
  }
  /**
   * Checks if a position can be unlocked based on its locking state and vesting schedules.
   *
   * This method evaluates whether a position is eligible for operations that require
   * unlocked liquidity, such as removing all liquidity or closing the position. It checks both
   * permanent locks and time-based vesting schedules.
   *
   * @private
   * @param {PositionState} positionState - The current state of the position
   * @param {Array<{account: PublicKey; vestingState: VestingState}>} vestings - Array of vesting accounts and their states
   * @param {BN} currentPoint - Current timestamp or slot number (depending on activation type of pool)
   *
   * @returns {Object} Result object containing unlock status and reason
   * @returns {boolean} result.canUnlock - Whether the position can be unlocked
   * @returns {string|undefined} result.reason - Reason why position cannot be unlocked (if applicable)
   */
  canUnlockPosition(positionState, vestings, currentPoint) {
    if (vestings.length > 0) {
      if (this.isPermanentLockedPosition(positionState)) {
        return {
          canUnlock: false,
          reason: "Position is permanently locked"
        };
      }
      for (const vesting of vestings) {
        if (!isVestingComplete(vesting.vestingState, currentPoint)) {
          return {
            canUnlock: false,
            reason: "Position has incomplete vesting schedule"
          };
        }
      }
    }
    return { canUnlock: true };
  }
  isPoolExist(pool) {
    return __async(this, null, function* () {
      const poolState = yield this._program.account.pool.fetchNullable(pool);
      return poolState !== null;
    });
  }
  /**
   * Computes the liquidity delta based on the provided token amounts and sqrt price
   *
   * @param {LiquidityDeltaParams} params - The parameters for liquidity calculation
   * @returns {Promise<BN>} - The computed liquidity delta in Q64 value.
   */
  getLiquidityDelta(params) {
    const {
      maxAmountTokenA,
      maxAmountTokenB,
      sqrtMaxPrice,
      sqrtMinPrice,
      sqrtPrice
    } = params;
    const liquidityDeltaFromAmountA = getLiquidityDeltaFromAmountA(
      maxAmountTokenA,
      sqrtPrice,
      sqrtMaxPrice
    );
    const liquidityDeltaFromAmountB = getLiquidityDeltaFromAmountB(
      maxAmountTokenB,
      sqrtMinPrice,
      sqrtPrice
    );
    return min2(liquidityDeltaFromAmountA, liquidityDeltaFromAmountB);
  }
  /**
   * Calculates swap quote based on input amount and pool state.
   * @param params - Swap parameters including input amount, pool state, slippage, etc.
   * @returns Swap quote including expected output amount, fee, and price impact.
   */
  getQuote(params) {
    const {
      inAmount,
      inputTokenMint,
      slippage,
      poolState,
      currentTime,
      currentSlot,
      inputTokenInfo,
      outputTokenInfo
    } = params;
    const {
      sqrtPrice: sqrtPriceQ64,
      liquidity: liquidityQ64,
      activationType,
      activationPoint,
      collectFeeMode,
      poolFees
    } = poolState;
    const {
      feeSchedulerMode,
      cliffFeeNumerator,
      numberOfPeriod,
      reductionFactor,
      periodFrequency
    } = poolFees.baseFee;
    const dynamicFee = poolFees.dynamicFee;
    let actualAmountIn = inAmount;
    if (inputTokenInfo) {
      actualAmountIn = calculateTransferFeeExcludedAmount(
        inAmount,
        inputTokenInfo.mint,
        inputTokenInfo.currentEpoch
      ).amount;
    }
    const aToB = poolState.tokenAMint.equals(inputTokenMint);
    const currentPoint = activationType ? currentTime : currentSlot;
    let dynamicFeeParams;
    if (dynamicFee.initialized) {
      const { volatilityAccumulator, binStep, variableFeeControl } = dynamicFee;
      dynamicFeeParams = { volatilityAccumulator, binStep, variableFeeControl };
    }
    const tradeFeeNumerator = getFeeNumerator(
      currentPoint,
      activationPoint,
      numberOfPeriod,
      periodFrequency,
      feeSchedulerMode,
      cliffFeeNumerator,
      reductionFactor,
      dynamicFeeParams
    );
    const { amountOut, totalFee, nextSqrtPrice } = getSwapAmount(
      actualAmountIn,
      sqrtPriceQ64,
      liquidityQ64,
      tradeFeeNumerator,
      aToB,
      collectFeeMode
    );
    let actualAmountOut = amountOut;
    if (outputTokenInfo) {
      actualAmountOut = calculateTransferFeeExcludedAmount(
        amountOut,
        outputTokenInfo.mint,
        outputTokenInfo.currentEpoch
      ).amount;
    }
    const minSwapOutAmount = getMinAmountWithSlippage(
      actualAmountOut,
      slippage
    );
    return {
      swapInAmount: inAmount,
      consumedInAmount: actualAmountIn,
      swapOutAmount: actualAmountOut,
      minSwapOutAmount,
      totalFee,
      priceImpact: getPriceImpact(nextSqrtPrice, sqrtPriceQ64)
    };
  }
  /**
   * Calculates swap quote based on desired output amount and pool state.
   * @param params - Swap parameters including output amount, pool state, slippage, etc.
   * @returns Swap quote including required input amount, fees, and price impact.
   */
  getQuoteExactOut(params) {
    const {
      outAmount,
      outputTokenMint,
      slippage,
      poolState,
      currentTime,
      currentSlot,
      inputTokenInfo,
      outputTokenInfo
    } = params;
    const {
      sqrtPrice: sqrtPriceQ64,
      activationType,
      collectFeeMode,
      poolFees
    } = poolState;
    const dynamicFee = poolFees.dynamicFee;
    const bToA = poolState.tokenAMint.equals(outputTokenMint);
    const tradeDirection = bToA ? 1 /* BtoA */ : 0 /* AtoB */;
    const currentPoint = activationType ? currentTime : currentSlot;
    let dynamicFeeParams;
    if (dynamicFee.initialized) {
      const { volatilityAccumulator, binStep, variableFeeControl } = dynamicFee;
      dynamicFeeParams = { volatilityAccumulator, binStep, variableFeeControl };
    }
    let actualAmountOut = outAmount;
    if (outputTokenInfo) {
      actualAmountOut = calculateTransferFeeIncludedAmount(
        outAmount,
        outputTokenInfo.mint,
        outputTokenInfo.currentEpoch
      ).amount;
    }
    const feeMode = getFeeMode(collectFeeMode, bToA);
    const { swapResult, inputAmount } = getSwapResultFromOutAmount(
      poolState,
      actualAmountOut,
      feeMode,
      tradeDirection,
      currentPoint
    );
    let actualInputAmount = inputAmount;
    if (inputTokenInfo) {
      actualInputAmount = calculateTransferFeeIncludedAmount(
        inputAmount,
        inputTokenInfo.mint,
        inputTokenInfo.currentEpoch
      ).amount;
    }
    const maxInputAmount = new BN10(
      Math.ceil(actualInputAmount.toNumber() * (1 + slippage / 100))
    );
    const priceImpact = getPriceImpact(swapResult.nextSqrtPrice, sqrtPriceQ64);
    return {
      swapResult,
      inputAmount: actualInputAmount,
      maxInputAmount,
      priceImpact
    };
  }
  /**
   * Calculates the deposit quote for liquidity pool.
   *
   * @param {GetDepositQuoteParams} params - The parameters for calculating the deposit quote.
   *
   * @returns {Promise<Object>} Deposit quote results
   * @returns {BN} returns.actualInputAmount - The actual amount used as input (after deducting transfer fees).
   * @returns {BN} returns.outputAmount - The calculated corresponding amount of the other token.
   * @returns {BN} returns.liquidityDelta - The amount of liquidity that will be added to the pool.
   */
  getDepositQuote(params) {
    const {
      inAmount,
      isTokenA,
      inputTokenInfo,
      outputTokenInfo,
      minSqrtPrice,
      maxSqrtPrice,
      sqrtPrice
    } = params;
    const actualAmountIn = inputTokenInfo ? calculateTransferFeeExcludedAmount(
      inAmount,
      inputTokenInfo.mint,
      inputTokenInfo.currentEpoch
    ).amount : inAmount;
    const { liquidityDelta, rawAmount } = isTokenA ? {
      liquidityDelta: getLiquidityDeltaFromAmountA(
        actualAmountIn,
        sqrtPrice,
        maxSqrtPrice
      ),
      rawAmount: (delta) => getAmountBFromLiquidityDelta(
        delta,
        sqrtPrice,
        minSqrtPrice,
        0 /* Up */
      )
    } : {
      liquidityDelta: getLiquidityDeltaFromAmountB(
        actualAmountIn,
        minSqrtPrice,
        sqrtPrice
      ),
      rawAmount: (delta) => getAmountAFromLiquidityDelta(
        delta,
        sqrtPrice,
        maxSqrtPrice,
        0 /* Up */
      )
    };
    const rawOutputAmount = new BN10(rawAmount(liquidityDelta));
    const outputAmount = outputTokenInfo ? calculateTransferFeeIncludedAmount(
      rawOutputAmount,
      outputTokenInfo.mint,
      outputTokenInfo.currentEpoch
    ).amount : rawOutputAmount;
    return {
      actualInputAmount: actualAmountIn,
      consumedInputAmount: inAmount,
      liquidityDelta,
      outputAmount
    };
  }
  /**
   * Calculates the withdrawal quote for removing liquidity from a concentrated liquidity pool.
   *
   * @param {GetWithdrawQuoteParams} params - The parameters for calculating the withdraw quote
   *
   * @param {Object|null} params.tokenATokenInfo - must provide if token a is token2022
   * @param {Object|null} params.tokenBTokenInfo - must provide if token b is token2022
   *
   * @returns {Promise<Object>} Withdrawal quote results
   * @returns {BN} returns.liquidityDelta - The amount of liquidity that will be removed from the pool
   * @returns {BN} returns.outAmountA - The calculated amount of token A to be received (after deducting transfer fees)
   * @returns {BN} returns.outAmountB - The calculated amount of token B to be received (after deducting transfer fees)
   */
  getWithdrawQuote(params) {
    const {
      liquidityDelta,
      sqrtPrice,
      maxSqrtPrice,
      minSqrtPrice,
      tokenATokenInfo,
      tokenBTokenInfo
    } = params;
    const amountA = getAmountAFromLiquidityDelta(
      liquidityDelta,
      sqrtPrice,
      maxSqrtPrice,
      1 /* Down */
    );
    const amountB = getAmountBFromLiquidityDelta(
      liquidityDelta,
      sqrtPrice,
      minSqrtPrice,
      1 /* Down */
    );
    return {
      liquidityDelta,
      outAmountA: tokenATokenInfo ? calculateTransferFeeExcludedAmount(
        amountA,
        tokenATokenInfo.mint,
        tokenATokenInfo.currentEpoch
      ).amount : amountA,
      outAmountB: tokenBTokenInfo ? calculateTransferFeeExcludedAmount(
        amountB,
        tokenBTokenInfo.mint,
        tokenBTokenInfo.currentEpoch
      ).amount : amountB
    };
  }
  /**
   * Calculates liquidity and corresponding token amounts for token A single-sided pool creation
   * Only supports initialization where initial price equals min sqrt price
   * @param params Parameters for single-sided pool creation
   * @returns Calculated liquidity delta
   */
  preparePoolCreationSingleSide(params) {
    const {
      tokenAAmount,
      initSqrtPrice,
      minSqrtPrice,
      maxSqrtPrice,
      tokenAInfo
    } = params;
    if (!initSqrtPrice.eq(minSqrtPrice)) {
      throw new Error("Only support single side for base token.");
    }
    const actualAmountIn = tokenAInfo ? tokenAAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenAAmount,
        tokenAInfo.mint,
        tokenAInfo.currentEpoch
      ).transferFee
    ) : tokenAAmount;
    const liquidityDelta = getLiquidityDeltaFromAmountA(
      actualAmountIn,
      initSqrtPrice,
      maxSqrtPrice
    );
    return liquidityDelta;
  }
  /**
   * Prepares parameters required for pool creation, including initial sqrt price and liquidity.
   * @private
   * @param {PreparePoolCreationParams} params - Initial token amounts for pool creation.
   * @returns init sqrt price and liquidity in Q64 format.
   */
  preparePoolCreationParams(params) {
    const {
      tokenAAmount,
      tokenBAmount,
      minSqrtPrice,
      maxSqrtPrice,
      tokenAInfo,
      tokenBInfo
    } = params;
    if (tokenAAmount.eq(new BN10(0)) && tokenBAmount.eq(new BN10(0))) {
      throw new Error("Invalid input amount");
    }
    const actualAmountAIn = tokenAInfo ? tokenAAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenAAmount,
        tokenAInfo.mint,
        tokenAInfo.currentEpoch
      ).transferFee
    ) : tokenAAmount;
    const actualAmountBIn = tokenBInfo ? tokenBAmount.sub(
      calculateTransferFeeIncludedAmount(
        tokenBAmount,
        tokenBInfo.mint,
        tokenBInfo.currentEpoch
      ).transferFee
    ) : tokenBAmount;
    const initSqrtPrice = calculateInitSqrtPrice(
      tokenAAmount,
      tokenBAmount,
      minSqrtPrice,
      maxSqrtPrice
    );
    const liquidityDeltaFromAmountA = getLiquidityDeltaFromAmountA(
      actualAmountAIn,
      initSqrtPrice,
      maxSqrtPrice
    );
    const liquidityDeltaFromAmountB = getLiquidityDeltaFromAmountB(
      actualAmountBIn,
      minSqrtPrice,
      initSqrtPrice
    );
    const liquidityDelta = min2(
      liquidityDeltaFromAmountA,
      liquidityDeltaFromAmountB
    );
    return {
      initSqrtPrice,
      liquidityDelta
    };
  }
  //// ANCHOR: MAIN ENDPOINT //////
  /**
   * Builds a transaction to create a permissionless pool.
   * @param params - Parameters for pool creation.
   * @returns Transaction builder.
   */
  createPool(params) {
    return __async(this, null, function* () {
      const {
        payer,
        creator,
        config,
        positionNft,
        tokenAMint,
        tokenBMint,
        initSqrtPrice,
        liquidityDelta,
        activationPoint,
        tokenAAmount,
        tokenBAmount,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = derivePoolAddress(config, tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const tx = yield this._program.methods.initializePool({
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        config,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID2,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return tx;
    });
  }
  /**
   * Builds a transaction to create a customizable pool.
   * @param params - Parameters for customizable pool creation.
   * @returns Transaction and related addresses.
   */
  createCustomPool(params) {
    return __async(this, null, function* () {
      const {
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        sqrtMinPrice,
        sqrtMaxPrice,
        liquidityDelta,
        initSqrtPrice,
        payer,
        creator,
        positionNft,
        poolFees,
        hasAlphaVault,
        collectFeeMode,
        activationPoint,
        activationType,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = deriveCustomizablePoolAddress(tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount: tokenBMint.equals(NATIVE_MINT2) ? max(tokenBAmount, new BN10(1)) : tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const transaction = yield this._program.methods.initializeCustomizablePool({
        poolFees,
        sqrtMinPrice,
        sqrtMaxPrice,
        hasAlphaVault,
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationType,
        collectFeeMode,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID2,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return { tx: transaction, pool, position };
    });
  }
  createCustomPoolWithDynamicConfig(params) {
    return __async(this, null, function* () {
      const {
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        sqrtMinPrice,
        sqrtMaxPrice,
        liquidityDelta,
        initSqrtPrice,
        payer,
        config,
        poolCreatorAuthority,
        creator,
        positionNft,
        poolFees,
        hasAlphaVault,
        collectFeeMode,
        activationPoint,
        activationType,
        tokenAProgram,
        tokenBProgram,
        isLockLiquidity
      } = params;
      const pool = derivePoolAddress(config, tokenAMint, tokenBMint);
      const {
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        preInstructions,
        tokenBadgeAccounts
      } = yield this.prepareCreatePoolParams({
        pool,
        tokenAMint,
        tokenBMint,
        tokenAAmount,
        tokenBAmount,
        payer,
        positionNft,
        tokenAProgram,
        tokenBProgram
      });
      const postInstruction = [];
      if (isLockLiquidity) {
        const permanentLockIx = yield this._program.methods.permanentLockPosition(liquidityDelta).accountsPartial({
          position,
          positionNftAccount,
          pool,
          owner: creator
        }).instruction();
        postInstruction.push(permanentLockIx);
      }
      const transaction = yield this._program.methods.initializePoolWithDynamicConfig({
        poolFees,
        sqrtMinPrice,
        sqrtMaxPrice,
        hasAlphaVault,
        liquidity: liquidityDelta,
        sqrtPrice: initSqrtPrice,
        activationType,
        collectFeeMode,
        activationPoint
      }).accountsPartial({
        creator,
        positionNftAccount,
        positionNftMint: positionNft,
        payer,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        poolCreatorAuthority,
        config,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        payerTokenA,
        payerTokenB,
        token2022Program: TOKEN_2022_PROGRAM_ID2,
        tokenAProgram,
        tokenBProgram,
        systemProgram: SystemProgram2.programId
      }).preInstructions(preInstructions).postInstructions(postInstruction).remainingAccounts(tokenBadgeAccounts).transaction();
      return { tx: transaction, pool, position };
    });
  }
  /**
   * Builds a transaction to create a position.
   * @param {CreatePositionParams} params - Parameters for position creation.
   * @returns Transaction builder.
   */
  createPosition(params) {
    return __async(this, null, function* () {
      const { ix } = yield this.buildCreatePositionInstruction(params);
      return new Transaction().add(ix);
    });
  }
  /**
   * Builds a transaction to add liquidity to an existing position.
   * @param {AddLiquidityParams} params - Parameters for adding liquidity.
   * @returns Transaction builder.
   */
  addLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        liquidityDelta,
        maxAmountTokenA,
        maxAmountTokenB,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenAAccount,
          BigInt(maxAmountTokenA.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenBAccount,
          BigInt(maxAmountTokenB.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        addLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Creates a new position and add liquidity to position it in a single transaction.
   * Handles both native SOL and other tokens, automatically wrapping/unwrapping SOL as needed.
   *
   * @param {CreatePositionAndAddLiquidity} params - Parameters for creating position and adding liquidity
   *
   * @returns {Transaction} A transaction that creates a position and adds liquidity
   *
   **/
  createPositionAndAddLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        positionNft,
        liquidityDelta,
        maxAmountTokenA,
        maxAmountTokenB,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const tokenAVault = deriveTokenVaultAddress(tokenAMint, pool);
      const tokenBVault = deriveTokenVaultAddress(tokenBMint, pool);
      if (tokenAMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenAAccount,
          BigInt(maxAmountTokenA.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          owner,
          tokenBAccount,
          BigInt(maxAmountTokenB.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const {
        ix: createPositionIx,
        position,
        positionNftAccount
      } = yield this.buildCreatePositionInstruction({
        owner,
        payer: owner,
        pool,
        positionNft
      });
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      const transaction = new Transaction();
      transaction.add(createPositionIx);
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        addLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to remove liquidity from a position.
   * @param {RemoveLiquidityParams} params - Parameters for removing liquidity.
   * @returns Transaction builder.
   */
  removeLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        vestings
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      return yield this._program.methods.removeLiquidity({
        liquidityDelta,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      }).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to remove liquidity from a position.
   * @param {RemoveLiquidityParams} params - Parameters for removing liquidity.
   * @returns Transaction builder.
   */
  removeAllLiquidity(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        vestings
      } = params;
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const removeAllLiquidityInstruction = yield this.buildRemoveAllLiquidityInstruction({
        poolAuthority: this.poolAuthority,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        removeAllLiquidityInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to perform a swap in the pool.
   * @param {SwapParams} params - Parameters for swapping tokens.
   * @returns Transaction builder.
   */
  swap(params) {
    return __async(this, null, function* () {
      const {
        payer,
        pool,
        inputTokenMint,
        outputTokenMint,
        amountIn,
        minimumAmountOut,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount
      } = params;
      const [inputTokenProgram, outputTokenProgram] = inputTokenMint.equals(
        tokenAMint
      ) ? [tokenAProgram, tokenBProgram] : [tokenBProgram, tokenAProgram];
      const {
        tokenAAta: inputTokenAccount,
        tokenBAta: outputTokenAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner: payer,
        tokenBOwner: payer,
        tokenAMint: inputTokenMint,
        tokenBMint: outputTokenMint,
        tokenAProgram: inputTokenProgram,
        tokenBProgram: outputTokenProgram
      });
      if (inputTokenMint.equals(NATIVE_MINT2)) {
        const wrapSOLIx = wrapSOLInstruction(
          payer,
          inputTokenAccount,
          BigInt(amountIn.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(payer);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return yield this._program.methods.swap({
        amountIn,
        minimumAmountOut
      }).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        payer,
        inputTokenAccount,
        outputTokenAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        referralTokenAccount
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to lock a position with vesting schedule.
   * @param {LockPositionParams} params - Locking parameters.
   * @returns Transaction builder.
   */
  lockPosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        pool,
        payer,
        vestingAccount,
        position,
        positionNftAccount,
        cliffPoint,
        periodFrequency,
        cliffUnlockLiquidity,
        liquidityPerPeriod,
        numberOfPeriod
      } = params;
      const lockPositionParams = {
        cliffPoint,
        periodFrequency,
        cliffUnlockLiquidity,
        liquidityPerPeriod,
        numberOfPeriod
      };
      return yield this._program.methods.lockPosition(lockPositionParams).accountsPartial({
        position,
        positionNftAccount,
        vesting: vestingAccount,
        pool,
        owner,
        payer,
        systemProgram: SystemProgram2.programId
      }).transaction();
    });
  }
  /**
   * Builds a transaction to permanently lock a position.
   * @param {PermanentLockParams} params - Parameters for permanent locking.
   * @returns Transaction builder.
   */
  permanentLockPosition(params) {
    return __async(this, null, function* () {
      const { owner, position, positionNftAccount, pool, unlockedLiquidity } = params;
      return yield this._program.methods.permanentLockPosition(unlockedLiquidity).accountsPartial({
        position,
        positionNftAccount,
        pool,
        owner
      }).transaction();
    });
  }
  /**
   * Builds a transaction to refresh vesting status of a position.
   * @param {RefreshVestingParams} params - Refresh vesting parameters.
   * @returns Transaction builder.
   */
  refreshVesting(params) {
    return __async(this, null, function* () {
      const instruction = yield this.buildRefreshVestingInstruction(params);
      return new Transaction().add(instruction);
    });
  }
  closePosition(params) {
    return __async(this, null, function* () {
      const { owner, pool, position, positionNftMint, positionNftAccount } = params;
      const instruction = yield this.buildClosePositionInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftMint,
        positionNftAccount
      });
      return new Transaction().add(instruction);
    });
  }
  /**
   * Builds a transaction to remove all liquidity from a position and close it.
   * This combines several operations in a single transaction:
   * 1. Claims any accumulated fees
   * 2. Removes all liquidity
   * 3. Closes the position
   *
   * @param {RemoveAllLiquidityAndClosePositionParams} params - Combined parameters
   * @returns {TxBuilder} Transaction builder with all required instructions
   * @throws {Error} If the position is locked or cannot be closed
   */
  removeAllLiquidityAndClosePosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAmountThreshold,
        tokenBAmountThreshold,
        vestings,
        currentPoint
      } = params;
      const { pool } = positionState;
      const { tokenAMint, tokenBMint } = poolState;
      const { canUnlock, reason } = this.canUnlockPosition(
        positionState,
        vestings,
        currentPoint
      );
      if (!canUnlock) {
        throw new Error(`Cannot remove liquidity: ${reason}`);
      }
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      if (vestings.length > 0) {
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position,
          positionNftAccount,
          pool,
          vestingAccounts: vestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const transaction = new Transaction();
      if (preInstructions.length > 0) {
        transaction.add(...preInstructions);
      }
      const liquidatePositionInstructions = yield this.buildLiquidatePositionInstruction({
        owner,
        position,
        positionNftAccount,
        positionState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold,
        tokenBAmountThreshold
      });
      transaction.add(...liquidatePositionInstructions);
      if (postInstructions.length > 0) {
        transaction.add(...postInstructions);
      }
      return transaction;
    });
  }
  /**
   * Builds a transaction to merge liquidity from one position into another.
   * This process:
   * 1. Claims fees from the source position
   * 2. Removes all liquidity from the source position
   * 3. Adds that liquidity to the target position
   * 4. Closes the source position
   *
   * @param {MergePositionParams} params - Parameters for merging positions
   * @returns {TxBuilder} Transaction builder with all required instructions
   * @throws {Error} If either position is locked or incompatible
   */
  mergePosition(params) {
    return __async(this, null, function* () {
      const {
        owner,
        positionA,
        positionB,
        positionBState,
        poolState,
        positionBNftAccount,
        positionANftAccount,
        tokenAAmountAddLiquidityThreshold,
        tokenBAmountAddLiquidityThreshold,
        tokenAAmountRemoveLiquidityThreshold,
        tokenBAmountRemoveLiquidityThreshold,
        positionBVestings,
        currentPoint
      } = params;
      const { canUnlock, reason } = this.canUnlockPosition(
        positionBState,
        positionBVestings,
        currentPoint
      );
      if (!canUnlock) {
        throw new Error(`Cannot remove liquidity: ${reason}`);
      }
      const pool = positionBState.pool;
      const { tokenAMint, tokenBMint, tokenAVault, tokenBVault } = poolState;
      const tokenAProgram = getTokenProgram(poolState.tokenAFlag);
      const tokenBProgram = getTokenProgram(poolState.tokenBFlag);
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstructions
      } = yield this.prepareTokenAccounts({
        payer: owner,
        tokenAOwner: owner,
        tokenBOwner: owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      let positionBLiquidityDelta = positionBState.unlockedLiquidity;
      if (positionBVestings.length > 0) {
        const totalAvailableVestingLiquidity = positionBVestings.reduce(
          (total, position) => {
            const available = getAvailableVestingLiquidity(
              position.vestingState,
              currentPoint
            );
            return total.add(available);
          },
          new BN10(0)
        );
        positionBLiquidityDelta = positionBLiquidityDelta.add(
          totalAvailableVestingLiquidity
        );
        const refreshVestingInstruction = yield this.buildRefreshVestingInstruction({
          owner,
          position: positionB,
          positionNftAccount: positionBNftAccount,
          pool,
          vestingAccounts: positionBVestings.map((item) => item.account)
        });
        refreshVestingInstruction && preInstructions.push(refreshVestingInstruction);
      }
      const tokenAWithdrawAmount = getAmountAFromLiquidityDelta(
        positionBLiquidityDelta,
        poolState.sqrtPrice,
        poolState.sqrtMaxPrice,
        1 /* Down */
      );
      const tokenBWithdrawAmount = getAmountBFromLiquidityDelta(
        positionBLiquidityDelta,
        poolState.sqrtPrice,
        poolState.sqrtMinPrice,
        1 /* Down */
      );
      const newLiquidityDelta = this.getLiquidityDelta({
        maxAmountTokenA: tokenAWithdrawAmount,
        maxAmountTokenB: tokenBWithdrawAmount,
        sqrtMaxPrice: poolState.sqrtMaxPrice,
        sqrtMinPrice: poolState.sqrtMinPrice,
        sqrtPrice: poolState.sqrtPrice
      });
      const transaction = new Transaction();
      if (preInstructions.length > 0) {
        transaction.add(...preInstructions);
      }
      const liquidatePositionInstructions = yield this.buildLiquidatePositionInstruction({
        owner,
        position: positionB,
        positionNftAccount: positionBNftAccount,
        positionState: positionBState,
        poolState,
        tokenAAccount,
        tokenBAccount,
        tokenAAmountThreshold: tokenAAmountRemoveLiquidityThreshold,
        tokenBAmountThreshold: tokenBAmountRemoveLiquidityThreshold
      });
      transaction.add(...liquidatePositionInstructions);
      const addLiquidityInstruction = yield this.buildAddLiquidityInstruction({
        pool,
        position: positionA,
        positionNftAccount: positionANftAccount,
        owner,
        tokenAAccount,
        tokenBAccount,
        tokenAMint,
        tokenBMint,
        tokenAVault,
        tokenBVault,
        tokenAProgram,
        tokenBProgram,
        liquidityDelta: newLiquidityDelta,
        tokenAAmountThreshold: tokenAAmountAddLiquidityThreshold,
        tokenBAmountThreshold: tokenBAmountAddLiquidityThreshold
      });
      transaction.add(addLiquidityInstruction);
      if ([tokenAMint.toBase58(), tokenBMint.toBase58()].includes(
        NATIVE_MINT2.toBase58()
      )) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner);
        closeWrappedSOLIx && transaction.add(closeWrappedSOLIx);
      }
      return transaction;
    });
  }
  /**
   * Builds a transaction to update reward duration.
   * @param {UpdateRewardDurationParams} params - Parameters including pool and new duration.
   * @returns Transaction builder.
   */
  updateRewardDuration(params) {
    return __async(this, null, function* () {
      const { pool, admin, rewardIndex, newDuration } = params;
      return yield this._program.methods.updateRewardDuration(rewardIndex, newDuration).accountsPartial({
        pool,
        signer: admin
      }).transaction();
    });
  }
  /**
   * Builds a transaction to update reward funder address.
   * @param {UpdateRewardFunderParams} params - Parameters including pool and new funder address.
   * @returns Transaction builder.
   */
  updateRewardFunder(params) {
    return __async(this, null, function* () {
      const { pool, admin, rewardIndex, newFunder } = params;
      return yield this._program.methods.updateRewardFunder(rewardIndex, newFunder).accountsPartial({
        pool,
        signer: admin
      }).transaction();
    });
  }
  /**
   * Builds a transaction to fund rewards in a pool.
   * @param {FundRewardParams} params - Funding parameters.
   * @returns Transaction builder.
   */
  fundReward(params) {
    return __async(this, null, function* () {
      const { rewardIndex, carryForward, pool, funder, amount } = params;
      const poolState = yield this.fetchPoolState(pool);
      const rewardInfo = poolState.rewardInfos[rewardIndex];
      const { vault, mint } = rewardInfo;
      const tokenProgram = getTokenProgram(rewardIndex);
      const preInstructions = [];
      const { ataPubkey: funderTokenAccount, ix: createFunderTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        mint,
        funder,
        funder,
        true,
        tokenProgram
      );
      createFunderTokenAccountIx && preInstructions.push(createFunderTokenAccountIx);
      if (mint.equals(NATIVE_MINT2) && !amount.isZero()) {
        const wrapSOLIx = wrapSOLInstruction(
          funder,
          funderTokenAccount,
          BigInt(amount.toString())
        );
        preInstructions.push(...wrapSOLIx);
      }
      return yield this._program.methods.fundReward(rewardIndex, amount, carryForward).accountsPartial({
        pool,
        rewardVault: vault,
        rewardMint: mint,
        funderTokenAccount,
        funder,
        tokenProgram
      }).transaction();
    });
  }
  /**
   * Builds a transaction to withdraw ineligible rewards from a pool.
   * @param {WithdrawIneligibleRewardParams} params - Parameters for withdrawal.
   * @returns Transaction builder.
   */
  withdrawIneligibleReward(params) {
    return __async(this, null, function* () {
      const { rewardIndex, pool, funder } = params;
      const poolState = yield this.fetchPoolState(pool);
      const rewardInfo = poolState.rewardInfos[rewardIndex];
      const { mint, vault, rewardTokenFlag } = rewardInfo;
      const tokenProgram = getTokenProgram(rewardTokenFlag);
      const preInstructions = [];
      const postInstructions = [];
      const { ataPubkey: funderTokenAccount, ix: createFunderTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        mint,
        funder,
        funder,
        true,
        tokenProgram
      );
      createFunderTokenAccountIx && preInstructions.push(createFunderTokenAccountIx);
      if (mint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(funder);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return yield this._program.methods.withdrawIneligibleReward(rewardIndex).accountsPartial({
        pool,
        rewardVault: vault,
        rewardMint: mint,
        poolAuthority: this.poolAuthority,
        funderTokenAccount,
        funder,
        tokenProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to claim partner fee rewards.
   * @param {ClaimPartnerFeeParams} params - Claim parameters including amounts and partner address.
   * @returns Transaction builder.
   */
  claimPartnerFee(params) {
    return __async(this, null, function* () {
      const {
        feePayer,
        receiver,
        tempWSolAccount,
        partner,
        pool,
        maxAmountA,
        maxAmountB
      } = params;
      const poolState = yield this.fetchPoolState(pool);
      const {
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAFlag,
        tokenBFlag
      } = poolState;
      const tokenAProgram = getTokenProgram(tokenAFlag);
      const tokenBProgram = getTokenProgram(tokenBFlag);
      const payer = feePayer != null ? feePayer : partner;
      const { tokenAAccount, tokenBAccount, preInstructions, postInstructions } = yield this.setupFeeClaimAccounts({
        payer,
        owner: partner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      });
      return yield this._program.methods.claimPartnerFee(maxAmountA, maxAmountB).accountsPartial({
        poolAuthority: this.poolAuthority,
        pool,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        partner,
        tokenAProgram,
        tokenBProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  /**
   * Builds a transaction to claim position fee rewards.
   * @param {ClaimPositionFeeParams} params - Parameters for claiming position fee.
   * @returns Transaction builder.
   */
  claimPositionFee(params) {
    return __async(this, null, function* () {
      const {
        receiver,
        tempWSolAccount,
        feePayer,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const payer = feePayer != null ? feePayer : owner;
      const { tokenAAccount, tokenBAccount, preInstructions, postInstructions } = yield this.setupFeeClaimAccounts({
        payer,
        owner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram,
        receiver,
        tempWSolAccount
      });
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstructions.length > 0 ? preInstructions : [],
        claimPositionFeeInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to claim position fee rewards.
   * @param {ClaimPositionFeeParams2} params - Parameters for claiming position fee.
   * @returns Transaction builder.
   */
  claimPositionFee2(params) {
    return __async(this, null, function* () {
      const {
        receiver,
        feePayer,
        owner,
        pool,
        position,
        positionNftAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      } = params;
      const payer = feePayer != null ? feePayer : owner;
      let tokenAOwner = receiver;
      let tokenBOwner = receiver;
      if (tokenAMint.equals(NATIVE_MINT2)) {
        tokenAOwner = owner;
      }
      if (tokenBMint.equals(NATIVE_MINT2)) {
        tokenBOwner = owner;
      }
      const {
        tokenAAta: tokenAAccount,
        tokenBAta: tokenBAccount,
        instructions: preInstruction
      } = yield this.prepareTokenAccounts({
        payer,
        tokenAOwner,
        tokenBOwner,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const postInstructions = [];
      if (tokenAMint.equals(NATIVE_MINT2) || tokenBMint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(owner, receiver);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      const claimPositionFeeInstruction = yield this.buildClaimPositionFeeInstruction({
        owner,
        poolAuthority: this.poolAuthority,
        pool,
        position,
        positionNftAccount,
        tokenAAccount,
        tokenBAccount,
        tokenAVault,
        tokenBVault,
        tokenAMint,
        tokenBMint,
        tokenAProgram,
        tokenBProgram
      });
      const transaction = new Transaction();
      transaction.add(
        ...preInstruction.length > 0 ? preInstruction : [],
        claimPositionFeeInstruction,
        ...postInstructions.length > 0 ? postInstructions : []
      );
      return transaction;
    });
  }
  /**
   * Builds a transaction to claim reward from a position.
   * @param {ClaimRewardParams} params - Parameters for claiming reward.
   * @returns Transaction builder.
   */
  claimReward(params) {
    return __async(this, null, function* () {
      const {
        feePayer,
        user,
        position,
        positionNftAccount,
        rewardIndex,
        skipReward,
        poolState,
        positionState
      } = params;
      const rewardInfo = poolState.rewardInfos[rewardIndex];
      const tokenProgram = getTokenProgram(rewardInfo.rewardTokenFlag);
      const preInstructions = [];
      const postInstructions = [];
      const { ataPubkey: userTokenAccount, ix: createUserTokenAccountIx } = yield getOrCreateATAInstruction(
        this._program.provider.connection,
        rewardInfo.mint,
        user,
        feePayer != null ? feePayer : user,
        true,
        tokenProgram
      );
      createUserTokenAccountIx && preInstructions.push(createUserTokenAccountIx);
      if (rewardInfo.mint.equals(NATIVE_MINT2)) {
        const closeWrappedSOLIx = yield unwrapSOLInstruction(user);
        closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
      }
      return yield this._program.methods.claimReward(rewardIndex, skipReward).accountsPartial({
        pool: positionState.pool,
        positionNftAccount,
        rewardVault: rewardInfo.vault,
        rewardMint: rewardInfo.mint,
        poolAuthority: this.poolAuthority,
        position,
        userTokenAccount,
        owner: user,
        tokenProgram
      }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    });
  }
  splitPosition(params) {
    return __async(this, null, function* () {
      const {
        firstPositionOwner,
        secondPositionOwner,
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        permanentLockedLiquidityPercentage,
        unlockedLiquidityPercentage,
        feeAPercentage,
        feeBPercentage,
        reward0Percentage,
        reward1Percentage
      } = params;
      return yield this._program.methods.splitPosition({
        permanentLockedLiquidityPercentage,
        unlockedLiquidityPercentage,
        feeAPercentage,
        feeBPercentage,
        reward0Percentage,
        reward1Percentage,
        padding: new Array(16).fill(0)
      }).accountsPartial({
        pool,
        firstPosition,
        firstPositionNftAccount,
        secondPosition,
        secondPositionNftAccount,
        firstOwner: firstPositionOwner,
        secondOwner: secondPositionOwner
      }).transaction();
    });
  }
};

// src/index.ts
var index_default = cp_amm_default;
export {
  ActivationPoint,
  ActivationType,
  BASIS_POINT_MAX,
  BIN_STEP_BPS_DEFAULT,
  BIN_STEP_BPS_U128_DEFAULT,
  CP_AMM_PROGRAM_ID,
  CollectFeeMode,
  CpAmm,
  DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
  DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
  DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
  FEE_DENOMINATOR,
  FeeSchedulerMode,
  LIQUIDITY_SCALE,
  MAX_CU_BUFFER,
  MAX_FEE_NUMERATOR,
  MAX_PRICE_CHANGE_BPS_DEFAULT,
  MAX_SQRT_PRICE,
  MIN_CU_BUFFER,
  MIN_SQRT_PRICE,
  ONE,
  Rounding,
  SCALE_OFFSET,
  TradeDirection,
  bpsToFeeNumerator,
  calculateInitSqrtPrice,
  calculateTransferFeeExcludedAmount,
  calculateTransferFeeIncludedAmount,
  decimalToQ64,
  index_default as default,
  deriveClaimFeeOperatorAddress,
  deriveConfigAddress,
  deriveCustomizablePoolAddress,
  derivePoolAddress,
  derivePoolAuthority,
  derivePositionAddress,
  derivePositionNftAccount,
  deriveRewardVaultAddress,
  deriveTokenBadgeAddress,
  deriveTokenVaultAddress,
  feeNumeratorToBps,
  getAllPositionNftAccountByOwner,
  getAllUserPositionNftAccount,
  getAmountAFromLiquidityDelta,
  getAmountBFromLiquidityDelta,
  getAvailableVestingLiquidity,
  getBaseFeeNumerator,
  getBaseFeeParams,
  getDynamicFeeNumerator,
  getDynamicFeeParams,
  getEstimatedComputeUnitIxWithBuffer,
  getEstimatedComputeUnitUsageWithBuffer,
  getExcludedFeeAmount,
  getFeeMode,
  getFeeNumerator,
  getFirstKey,
  getIncludedFeeAmount,
  getLiquidityDeltaFromAmountA,
  getLiquidityDeltaFromAmountB,
  getMaxAmountWithSlippage,
  getMinAmountWithSlippage,
  getNextSqrtPrice,
  getNextSqrtPriceFromAmountARoundingDown,
  getNextSqrtPriceFromAmountBRoundingUp,
  getNextSqrtPriceFromOutput,
  getOrCreateATAInstruction,
  getPriceFromSqrtPrice,
  getPriceImpact,
  getSecondKey,
  getSimulationComputeUnits,
  getSqrtPriceFromPrice,
  getSwapAmount,
  getSwapResultFromOutAmount,
  getTokenDecimals,
  getTokenProgram,
  getTotalLockedLiquidity,
  getUnClaimReward,
  isVestingComplete,
  mulDiv,
  positionByPoolFilter,
  pow,
  q64ToDecimal,
  unwrapSOLInstruction,
  vestingByPositionFilter,
  wrapSOLInstruction
};
//# sourceMappingURL=index.mjs.map